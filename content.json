{"pages":[{"title":"","text":"I'm Harrison-1eo An undergraduate student at the School of Cyberspace Security of Beihang University If you have any questions, welcome to contact me via email. 😊😊😊😁😁😁😋😋😋 😎😎😎🤗🤗🤗🤩🤩🤩 😝😝😝🫣🫣🫣🥺🥺🥺","link":"/about/index.html"},{"title":"","text":"Harrison-1eo (Harrison) (github.com)","link":"/links/index.html"}],"posts":[{"title":"python 基础语法","text":"第一章 python简介 第二章 python基础语法 2.1 简单输出 12print(666)print([输出项1,输出项2,...] [,sep=分隔符] [,end=结束符]) 默认分隔符为空格，结束符为换行符 2.2 注释 使用 # 表示单行注释 使用 \"\"\" 表示多行注释 2.3 变量 变量是没有类型的，但是变量存储的数据是有类型的 可以使用 type() 查看变量类型 123456money = 50print(\"我还有\", money, \"块钱\")print(type(money))type_int = type(money)print(type_int)print(type(type_int)) 输出结果为 1234我还有 50 块钱&lt;class 'int'&gt;&lt;class 'int'&gt;&lt;class 'type'&gt; 2.4 数据类型显式转换 可以使用 int(x) float(x) str(x) 转换成相应的数据类型 注意 任何类型都可以转换成字符串类型，但是转换为int和float类型之前需要确保能转换到相应的类型 2.5 运算符 常用运算符 + - * / % // 两个斜杠为取整除,即只保留结果的整数部分 ** 两个星号为幂运算 1234print(9//2)print(9.0//2.0)print(3**2)# 输出结果为4 4.0 9 not：取反运算符 and：与运算符 or 或运算符 成员运算符 - in：在指定序列中找到指定的值则返回True，否则返回False - not in 身份运算符 - is：判断两个标识符是否引用了同一个对象 - not is 2.6 字符串 字符串定义法：单引号，双引号，三引号（可以换行） 字符串内部可以使用转义字符 \\ 来输出引号 可以使用加号（+）来对字符串进行拼接，但是不用拼接其他类型的变量,需要转换成字符串类型 ### 字符串格式化表示法 形式类似于c语言中printf括号中的内容 123massage = \"第%d个苹果重%.2f%s\" % (3, 1.2, \"kg\")print(massage)# 输出结果：第3个苹果重1.20kg 此处类似于%5.4f格式的效果与C语言相同 注意，在本格式化表示方法中，小数会自动在后面添加若干个0 字符串快速格式化 f\"内容{变量}\"的格式来快速格式化 123money = 1.2massage = f\"我有{money}这么多钱\"# 输出结果：我有1.2这么多钱 此种方法不需要进行精度处理，数字内容不变，小数位数也不变 2.7 input语句 使用 input() 语句可以从键盘获取输入 使用一个变量接收（存储）input语句获取的键盘输入数据即可 无论输入的数据是什么，都是存储为string类型的 第三章 Python判断语句 3.1 布尔类型和比较运算符 bool类型表示真和假 True 为真，为 1 False 为假，为 0 比较运算符与C语言相同，注意，==表示判断是否相等 3.2 if语句 语法格式： 123456789if 条件： 语句1elif 条件2： 语句2elif 条件3： 语句3...else： 语句N 注意，一定要进行缩进，python通过缩进的对齐判断语句的归属 条件判断语句的结果一定是bool类型的结果 第四章 Python循环语句 4.1 while循环 语法格式： 1234while 条件： 语句1 语句2 ... ## 4.2 for循环 - while循环的循环条件是自定义的，自行控制循环条件 - for循环是一种”轮询”机制，是对一批内容进行”逐个处理”将数据集中的每一个内容取出来进行处理。for循环是无法定义循环条件的，只能从数据集中依次取出内容 语法格式： 12for 临时变量 in 待处理数据集: 循环满足条件时执行的代码 例如： 12345name = \"itheima\"# for循环处理字符串for x in name: print(x)# 运行结果为将字符串中字符一个一个拿出来输出 语法格式中\"待处理数据集\"实际上为一个序列类型，其中包括字符串，列表，元组等等 通过range语句可以获得一个简单的数字序列，用于for循环中 range(num) 为从0到num的数字序列(不包含num本身) range(num1,num2) 为从num1到num2的数字序列(不包含num2本身) range(num1,num2,step) 为从num1到num2的数字序列(不包含num2本身)，步长为step 临时变量在编程规范上，作用范围（作用域）只限定在for循环内部 如果在for循环外部访问临时变量： 实际上是可以访问到的。但是在编程规范上，是不允许、不建议这么做的 4.3 continue和break 在嵌套循环中，只能作用在所在的循环上，无法对上层循环起作用 4.4 pass pass是空语句，不执行任何操作，一般用作占位语句，保持程序的完整性 第五章 Python函数基础 5.1 函数的基本定义 123def 函数名(传入参数)： 函数体 return 返回值 应先定义函数，后调用函数 参数不需要，可以省略 返回值不需要，可以省略 可以在def一行下面采用多行注释的方式写该函数的说明文档 5.2 None类型 Python中有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt; 无返回值的函数，实际上就是返回了：None这个字面量 None表示：空的、无实际意义的意思 return None，效果等同于不写return语句 在if判断中，None等同于False 一般用于在函数中主动返回None，配合if判断做相关处理 用于声明无内容的变量上 定义变量，但暂时不需要变量有具体值，可以用None来代替，例如name = None 5.3 局部变量与全局变量 在某一函数体内的为局部变量，只能在该函数体内生效 使用 global 关键字可以在函数内部声明全局变量 第六章 Python数据容器 6.1 list 列表 列表的特点： - 可以容纳多个元素（上限为2**63-1个） - 可以容纳不同类型的元素（混装） - 数据是有序存储的（有下标序号） - 允许重复数据存在 - 可以修改（增加或删除元素等） 6.1.1 列表的定义 12345# 定义变量变量名称 = [元素1, 元素2, ...]#定义空列表变量名称 = []变量名称 = list() 以 [] 作为表示，列表内每个元素之间以 , 隔开 列表可以一次存储多个数据，并且可以是不同的数据类型，支持嵌套 6.1.2 列表的下标索引 从头开始第一个的索引为0，一直到最后，如 list[2] 从尾开始最后一个的索引是-1，一直到最前 如果是列表嵌套列表，则可以使用类似C语言二位数组的表达方式，如 list[1][2] 要注意下标索引的取值范围，超出范围无法取出元素，并且会报错 6.1.3 列表的常用方法 在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法 方法的使用格式为 对象.方法(传入参数) 方法 作用 列表.index(元素) 查找指定元素在列表的下标找不到报错ValueError 列表[下标] = 值 修改特定位置的值 列表.insert(下标, 元素) 在指定的下标位置，插入指定的元素 列表.append(元素) 将指定元素，追加到列表的尾部 列表.extend(其它数据容器) 将其它数据容器的内容取出，依次追加到列表尾部 del 列表[下标] 删除列表指定下标元素 列表.pop(下标) 删除列表指定下标元素 列表.remove(元素) 从前向后，删除此元素第一个匹配项 列表.clear() 清空列表 列表.count(元素) 统计此元素在列表中出现的次数找不到报错ValueError len(列表) 统计容器内有多少元素 6.2 tuple 元组 元组的特点： - 有序、任意数量元素、允许重复元素 - 不可修改 元组内容不可以直接修改，会报错 如果元组内部有列表元素，列表中的内容可以修改 6.2.1 列表的定义 12345# 定义元组变量名称 = (元素1, 元素2, ...)#定义空元组变量名称 = ()变量名称 = tuple() 如果定义的元组只有一个元素时，在元素1后面要加一个逗号，例如 (1,)，不然则不是元组类型 6.2.2 元组的下标索引 写法与列表相同，索引从0开始计算 6.2.3 元组的常用方法 元组.index() 元组.count() len(元组) 实际效果见6.1.3表格 6.3 str 字符串 字符串的特点： - 只可以储存字符串，长度任意 - 不可修改，如果要修改，只能得到一个新的字符串 6.3.1 字符串的下标索引 类似于C语言中字符数组，可以通过下标索引取出字符，索引从0号开始计算，但是没有最后的‘\\0’占位符 6.3.2 字符串的常用方法 str.index(参数)参数可以是一个字符，也可以是一个字符串 str.replace(m,n)将字符串中的m字符串替换为n字符串，返回一个新的字符串 str.split(分隔符)按照指定的分割符将字符串分为多个字符串，返回一个列表对象 str.strip(参数)去除字符串前后的参数中的内容，注意是按照字符去除，而不是整体的字符串匹配。如果不传入参数则默认去除字符串前后的空格和换行 str.count(参数) len(str) 6.4 序列的切片 序列是指能用下标索引的容器，例如：列表、元组、字符串 切片：从一个序列中取出一个子序列 语法：序列[起始下标：结束下标：步长]，返回一个新的序列 结束下标表示到某位结束，不包含结束位 起始下标留空表示从头开始，结束下标留空表示截取到结尾 步长可以为正数，也可以为负数，表示反向取，主要这时起始下标和结束下标也要反向标记 str[::-1]相当于将字符串从尾到头倒序输出 6.5 set 集合 集合的特点： - 无序，不支持下标索引访问 - 可以修改 - 数据不能重复 - 可以容纳多个数据，不同的数据类型 6.5.1 集合的定义 1234# 定义集合变量名称 = {元素1, 元素2, ...}#定义空集合变量名称 = set() 6.5.2 集合的常用方法 set.add(ele) set.remove(ele) set.pop()没有参数，随机取出一个元素，并将该元素从集合中去除 set.clear()清空集合 set1.difference(set2)取出集合1对集合2的差集（集合1有集合2没有的内容），返回一个集合 set1.difference_update(set2)对比集合1和集合2，在集合1内删除和集合2相同的元素。集合1被修改，集合2不变 set1.union(set2)将两个集合合并，返回一个新的集合 len(set) 6.6 dict 字典 6.6.1 字典的定义 12345# 定义字典变量名称 = {key: value, key: value, ...}#定义空字典变量名称 = {}变量名称 = dict() 6.6.2 字典的常用方法 访问时可以使用dict[key]获取某一键的值 dict.keys()返回包含所有键的列表 dict.has_key(k)检查字典中是否含有某一键 dict.values()返回包含所有值的列表 dict.get(key)返回字典的键 dict.items()返回有键值对组成的元组 dict.copy()复制字典到另一字典 del dict(key)删除指定键的元素 dict.clear()清除键的所有元素 dict.pop(key)弹出某一键的值，并从字典中删除 第七章 Python函数进阶 7.1 函数的多返回值 return函数后面可以写多个返回值，用逗号隔开 1234def test_return(): return 1, \"hello\", Truex, y, z = test_return()# x,y,z会对应接收到相应的值 7.2 函数的多种传参方式 Python的传参是传对象引用，是一个对象的内存地址，是传值和传址的一个综合 如果收到的是一个可以改变（字典或者列表）的对象的引用，就能修改对象的初始值；如果是一个不可修改（数字、字符、字符串或者元组）的对象，则不能直接修改原始对象。 7.2.1 位置参数 调用函数时根据函数定义的参数位置来传递参数 7.2.2 关键值参数 函数调用时通过“键=值”形式传递参数 123456def user_info(name, age, gender): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")# 关键字参数user_info(name='小王', age=11, gender='女')user_info(age=10, gender='女', name='潇潇') # 可以不按照参数的定义顺序传参user_info('甜甜', gender='女', age=9) # 不表明名称的位置需对应 7.2.3 缺省参数 参数提供默认值，调用函数时可不传该默认参数的值 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用 12345def user_info(name, age, gender='男'): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")user_info('小天', 13, '女')user_info('小乐', 13) 7.2.4 不定长参数 不定长参数有两种类型 1. 位置传递（元组，*号） 2. 关键字传递（字典，**号） 1234567891011# 不定长 - 位置不定长, *号# 不定长定义的形式参数会作为元组存在，接收不定长数量的参数传入def user_info(*args): print(f\"args参数的类型是：{type(args)}，内容是:{args}\")user_info(1, 2, 3, '小明', '男孩')# 不定长 - 关键字不定长, **号def user_info(**kwargs): print(f\"args参数的类型是：{type(kwargs)}，内容是:{kwargs}\")user_info(name='小王', age=11, gender='男孩') 7.3 函数可以作为参数传递 函数本身是可以作为参数，传入另一个函数中进行使用的。 将函数传入的作用在于：传入计算逻辑，而非传入数据。 1234567891011# 定义一个函数，接收另一个函数作为传入参数def test_func(compute): result = compute(1, 2) # 确定compute是函数 print(f\"compute参数的类型是:{type(compute)}\") print(f\"计算结果：{result}\")# 定义一个函数，准备作为参数传入另一个函数def compute(x, y): return x + y# 调用，并传入函数test_func(compute) 在如上的例子中，test_func函数中需要一个函数，对1和2进行某种运算，外部定义了一个compute作为参数传递给了test_func函数 7.4 lambda匿名函数 lambda关键字，可以定义匿名函数（无名称），无名称的匿名函数，只可临时使用一次。 lambda函数基本语法：lambda 传入参数：函数体（一行代码） 第八章 文件操作 8.1 打开文件 使用open函数打开文件，并返回一个文件对象 myfile = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]]) mode为文件的读写模式 | mode | 模式 | 文件不存在时 | 是否覆盖写 | | :---: | :---: | :----------: | :---------------: | | r | 只读 | 报错 | - | | r+ | 读写 | 报错 | 是 | | w | 只写 | 新建文件 | 是 | | w+ | 读写 | 新建文件 | 是 | | a | 只写 | 新建文件 | 否，从EOF处开始写 | | a+ | 读写 | 新建文件 | 否，从EOF处开始写 | 在字母后面加上b表示用二进制打开相应的文件，如rb+ 用w或a打开文件时，文件指针指向文件末尾；用r打卡文件时，文件指针指向文件开头 encoding为编码格式（推荐使用UTF-8）。encoding的位置不是第三位，如果要说明的话，应使用关键字参数。也可省略。 8.2 文件的常用属性 file.name：返回文件的名称； file.mode：返回打开文件时，采用的文件打开模式； file.encoding：返回打开文件时使用的编码格式； file.closed：判断文件是否己经关闭。 8.3 文件的常用方法 file.close() file.flush()刷新输出缓存 file.read([size])如果设置了size，则读取size字节；如果没设置，则读取问价全部内容。 file.readline([size])如果设置了size，size小于改行总字节，则读取size字节；如果大于，则读取该行的所有内容 file.readlines()读取完文件，返回每行组成的列表 file.write(str)将字符串写入文件 file.writelines(sequence of strings)写多行到文件，参数可以是字符串，也可以是列表 file.seek(n)将文件指针移动到第n字节，0表示开头 file.tell()返回文件指针当前的位置 8.4 shutil模块 shutil模块中包含一些函数，用于复制、移动、改名和删除文件 第九章 Python异常、模块与包 9.1 异常 捕获常规异常 12345678try: 可能发生错误的代码except: 如果出现异常执行的代码else: 如果异常不出现执行的代码finally: 无论异常是否出现都要执行的代码 捕获指定异常 12345try: print(name)except NameError as e: print('name变量名称未定义错误')# 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 捕获多个异常，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写 1234try: print(1/0)except (NameError, ZeroDivisionError): print('ZeroDivision错误...') 捕获所有异常，并输出 1234try: print(name)except Exception as e: print(e) 异常是具有传递性的 当我们想要保证程序不会因为异常崩溃的时候, 就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到main函数中, 这样就可以确保所有的异常都会被捕获 9.2 模块 模块是一个python文件，里面有类、函数、变量等等，可以导入模块来用 模块的导入语法： [from 模块名] import [模块|类|变量|函数| * ] [as 别名] 模块的使用： 模块名.功能名 12345678910# 使用import导入time模块中的sleep功能# 方法1import timetime.sleep(5)# 方法2from time import sleepsleep(5)# 方法3from time import *sleep(5) 注意：当导入多个模块，且模块内有重名的功能时，调用这个重名的功能时，使用的是后导入模块的该功能 if __name__ == '__main__': 可以用于某模块内部的运行代码，防止在导入模块时执行内置语句 __all__ = [' ' , ' ' , ...] 当模块文件中有 __all__ 变量，使用 from xxx import * 导入时，只能导入列表中的元素 9.3 包 包就是一个文件夹，其中包含了很多的py文件和一个_init.py文件","link":"/2022/08/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"密码学期末复习（PPT）","text":"1. 概述 1.1 引言 1949年，香农的《保密系统通信理论》将密码学推向基于信息论的学科，近代密码学诞生。 1976年，Diffie和Hellman提出公钥密码学的思想，开启了现代密码学。 我国密码分级：核心密码（核心机密）、普通密码（高于商用）、商用密码（非机密）、个人密码（个人隐私）。前三种密码都由国家密码管理局统一管理。 1.2 网络安全概念 信息安全三要素（CIA）： 机密性 数据保密性：隐私或者秘密数据不向非授权者泄露、也不被他们使用 隐私性：个人能够控制和确定自身相关的哪些信息可以被收集、保存、公开及向谁公开 完整性 数据完整性：信息和程序只能以特定的方式进行改变 系统完整性：系统以一种正常的方式执行预定的功能，免于被非法的操控 可用性 除此之外，还需要一些安全概念： 真实性：一个实体是真实、可被验证的，或者信息和信息的来源是正确的。 可追溯性：实体的行为可以追溯到唯一的该实体。 安全泄露事件的影响： 执行使命的能力 资产损失 经济损失 对个人的伤害 低 能力一定程度降低，效果稍有降低 较少 很小 很小 中 能力显著降级，能完成主要功能，但效果明显降低 显著 显著 显著，但是不威胁生命安全 高 能力严重降级，不能完成一项或多项功能 大部分 大部分 严重，包括威胁生命安全 OSI安全框架：安全方面：攻击、机制和服务 安全攻击：任何危及信息系统安全的行为。 安全机制：用来检测、阻止攻击或从攻击状态恢复到正常状态的过程。 安全服务：利用一种或多种安全机制进行反攻击。 安全攻击 安全漏洞是信息系统产生安全问题的内因，也叫缺陷、隐患、脆弱性。 安全威胁是信息系统产生安全问题的外因，也叫攻击。 安全威胁分为： 自然威胁：各种自然灾害、设备老化等 人为威胁：对信息及信息系统的人为攻击，通过找弱点，到达破坏、欺骗等效果 攻击方式有两种：主动攻击和被动攻击。 被动攻击：窃听，不影响正常的通信，不对信息进行任何修改，以获取信息为目的。 被动攻击分为：信息内容的泄露、流量分析。 主动攻击：对数据流进行篡改，或者产生假的信息。 主动攻击包括： 拒绝服务：对系统可用性进行攻击。 消息修改：修改消息内容、延迟传输、修改消息顺序等。破坏完整性。 伪装：假装成其他实体。对真实性进行攻击。 重放：将截获的信息再次发送。 安全服务：对系统资源进行特殊保护的处理或者通信服务。 数据保密性：防止消息内容泄露，被窃听。防止被动攻击 认证：保证通信的真实性。包括单向通信和双向通信 数据完整性：保证所接受的信息是未经修改或重放的，还能用于对一定程度损坏的数据的恢复。 不可否认性：接收者能证明消息的真实来源，发送者能证实接收者已经接受了消息 访问控制：检查用户是否对某一资源有访问权。实现方式是认证 安全机制 大多数机制的共同点：密码技术 特定的安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证 普遍的安全机制：可信功能、安全标签、事件检测、安全审计追踪、安全恢复 安全服务与机制间的联系（表格） 网络安全模型：两个基本成分和一个可选成分： 消息的安全变换 通信双方共享的秘密信息 有时需要一个可信第三方 3. 传统加密技术 3.1 密码学发展史 三个阶段： -1949：古典密码 1949-1975：计算机使得基于复杂计算的密码成为可能。数据的安全性基于密钥而不是算法的保密。 1976-：公钥密码、对称密码进一步发展 3.2 对称密码模型 密钥为，密钥可能值的范围为密钥空间。加解密函数为： 对于加解密过程，明文加密后再解密得到的内容必须和原来明文相同。 密码学：研究信息的保密和复原保密信息以获取其真实内容的学科称为密码学。它包括密码编码学和密码分析学。 密码编码学：研究对信息进行编码实现隐蔽信息的一门学科。 密码分析学：不知道任何加密细节的条件下解密消息的技术，即“破译”。 对称密码： 又称传统密码、常规密码、私钥密码、单钥密码 发送方和接收方共享一个共同的密钥。 对称密码安全的两个必备条件： 加密算法必须足够强 发送者和接收者在某种安全的形式下获得密钥并且保证密钥的安全 Kerckhoff原则：系统的保密性不依赖于对加密体制或算法的保密，而依赖于对密钥的保密。 密码编码学的三个特征： 明文转换为密文的运算类型：代替（元素映射到另一个元素）、置换（元素的重新排列）。要求运算是可逆的。 所用的密钥数：单钥密码（基于计算安全性，即破译的计算量下限）、双钥密码（基于可证明安全性，即依赖数学难题） 处理明文的方法：分组密码、序列密码（流密码） 密码分析学： 目标：得到密钥 攻击方法：密码分析（利用算法的性质、明文的特性、明密文对）、穷举攻击 基于密码分析的攻击： 唯密文攻击 已知明文攻击：已知多个明文-密文对 选择明文攻击：由破译者选择的明文信息及其密文 选择密文攻击：由破译者选择的密文信息及其明文 选择文本攻击：选择明文+密文攻击 无条件安全：算法产生的密文不能给出唯一决定明文的足够信息，此时敌手获得多少密文用多长时间都不能解密密文。仅当密钥至少和明文一样长时，才能达到无条件安全。即只有一次一密方案是无条件安全的。 计算上安全：破译密文的代价超过被加密信息的价值或破译密文所花的时间超过信息的有用期。计算上安全弱于无条件安全。 穷举攻击：敌手想找出一个私钥，采用穷举攻击。若k是均匀随机分布的，则敌手需要平均尝试： 3.3 代替技术 凯撒密码 字母表位移k位 共有26种可能的密钥，25种有效 加密： 解密： 采样密码（乘法密码） 明文字母表每隔k位取出一个 要求密钥k与26互素，有 个 可用密钥 加密： 解密： 仿射代替密码 加法和乘法结合 q=26时，共26*12-1 = 311 个可用密码（减去的是不变的变换） 加密： 解密： 单表代替密码： 随机映射 密钥数目： 缺陷：密文字母带有明文的统计特性，明文中一个元素仅影响密文中一个元素 语言的统计特性： 单字母：极大概率：e，大概率字母：tao，较大概率：inshr 多字母 单词特性 单表代替密码之所以容易被攻击，是因为每个密文字母都是用同一个代替密表加密而成的，相同的密文字母对应着相同的明文字母。实际上只是改变字母的名称。 Playfair密码 多字母代替密码，5*5矩阵，先填充单词，再填充剩下的。I=J 加密：明文两个字母一组，如果两个字母相同则在中间插入一个填充字母。同行：循环向右，同列：循环向下，对角线：另一对角线，按加密两字母的行排序 优点：安全性优于单表代替密码，使用频率分析困难 Hill密码 多字母代替密码，利用矩阵 加密： 解密： 优点：完全隐藏了单字母的频率特性，可以抵抗唯密文攻击 容易被已知明文攻击破解 3.4 多表代替技术 多表代替：对每位明文采用不同的单表代替。当明文和密钥一样长时成为一次一密密码。 维吉尼亚密码：明文，密钥，密文 26*26表格，行和列均为a-z，表内为每行以a.b.c...z开头的凯撒密码 加密： 解密： 博福特密码： 加密： 解密： 弗纳姆Vernam密码： 与密钥诸位异或 一次一密： 在Vernam密码中，如果采用的密钥不重复就是一次一密体制 在理论上不可被破解，但是在实际上不可行 多表代替密码的破译： 对于周期多表代替密码，可以转换成多组单表代替密码进行破译。 3.5 其他技术 置换技术 轮转机 隐写术 4. 分组密码和数据加密标准 4.1 Feistel密码 分组密码：明文分组加密，得到等长的密文分组。解密算法是加密算法的逆运算。 可逆变换：每个明文分组唯一对应一个密文分组。映射的总数是 。称为理想分组密码。 混淆：是密文和加密密钥之间关系变得复杂，以阻止攻击者发现密钥。 扩散：每个密文字母尽可能受多个明文数字的影响，使得明文的统计特性消散在密文中。 乘积密码：在单个加密机制中依次使用两个或两个以上不同类型的基本密码，所得结果的密码强度将强于每个单个密码的强度。 Feistel密码是一种特殊的SP网络，交替使用代替和置换，增强密码的扩散和混淆性能。 Feistel密码的结构：加密和解密完全相同 在Feistal密码结构中，中间经过若干轮上述基本结构，加密和解密的最后都要添加一步交换L和R F函数不必可逆。 Feistel密码的解密过程与加密过程实质相同，无需区分实现加密和解密算法，只是密钥使用顺序不同。 Feistel密码的设计： 分组越大，安全性越高，但是计算越慢 密钥越长，安全性越高，但是计算越慢 循环越多，安全性越高 子密钥产生算法和轮函数设计越复杂，安全性越高 DES、SM4为分组密码 3.2 数据加密标准(DES) DES（Data Encryption Standard）使用56比特的密钥加密64位的明文，得到64位的密文。 算法的实现过程： 初始置换IP： 16轮迭代运算：，子密钥长48位 迭代运算过程包含4步： --32bit--&gt; 扩展置换E --48bit--&gt; 与子密钥异或 --48bit--&gt; S盒代替 --32bit--&gt; 置换运算P --32bit--&gt; 逆置换IP-1： S盒：唯一的非线性变换，决定了算法的安全强度，起到混淆的作用。DES中的S盒接受6bit，第一位和最后一位组成选择行，中间4位选择列，输出4比特 子密钥的产生： 密钥扩展算法要求子密钥的统计独立性和灵敏性，从一些子密钥中获得其他子密钥在计算上是困难的。 雪崩效应：明文或密钥的一点小的变动都引起密文的较大变化。P置换的目的是提供雪崩效应。 弱密钥：初始密钥产生的16个子密钥相同。 半弱密钥：存在不相等的，使得。DES一共有6对半弱密钥。 差分密码攻击：通过比较两个已知明文差异的明密文对，在使用相同子密钥的情况下搜索密文中的已知差异。 线性密码分析：基于找到DES中进行变换的线性近似，可以在有2^47个已知明文的情况下破译DES密钥，但实践中仍不可行。 分组密码的整体结构：Feistel结构和SP网络 SP网络结构：每一轮中，轮输入首先被一个由子密钥控制的可逆函数S（混淆）作用，然后再对所得结果用置换（或可逆线性变换）P（扩散）作用。SP网络结构可以更快的扩散，但加解密通常不相似。 3.3 多重加密与三重DES算法 闭合的加密算法：对于任意密钥，都存在，使得： 对于闭合的加密算法，多次加密并不能增强安全性。但是DES不是一个闭合的加密算法，所以二重DES和三重DES有一定的价值。 二重DES的强度不等于56*2=112bit密钥的密码强度，会受到中途相遇攻击： 中途相遇攻击： 加密： 已知一对。对所有可能的种对进行加密，得到z，存储为一个字典。对所有可能的种对进行解密，得到z，此时可以查找上述字典，配对x和y，一旦找到则确定两个密钥。 两重DES的密文有种，密钥有种，因此有种密钥能产生给定的密文。 攻击法最大的实验次数是次，即算法难度为。 如果再用一对进行对密钥的验证，则错误率降为。 三重DES： 加密： 解密： 3.4 DES的差分密码分析 通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。 6. 高级加密标准 6.1 代换-置换网络(SPN) 乘积密码体制：先用一种密码进行加密，对加密结果使用另一种方法进行加密。如果第二种加密方式是自己，则为二重成绩，记为。n重成绩记为。 如果，则称密码是幂等的。幂等密码体制和自己做乘积，不能提高算法安全性。古典密码大部分都是幂等的。 迭代密码：如果密码不是幂等的，则多次迭代有可能提高安全性。一种构造简单的非幂等密码体制的方法是对两个不同的密码体制做乘积，并且保证两个密码体制是不能交换的。 在代换(S)-置换(P)网络中：加密：，解密： 对于任意的线性变换，都有： 6.2 高级加密标准(AES) Rijndael是一个迭代型分组密码，其分组长度和密钥长度都可变，可以为128比特、192比特、256比特。Rijndael使用非线性结构的S-boxes，能抵抗所有已知的攻击。Rijndael中轮函数由3层不同的可逆均匀变换组成，分别为线性混合层、非线性层、密钥加层。 在第一轮之前使用一个初始密钥加层，目的是：使加解密相似、对安全性无意义、有利于差分分析。 AES是一个迭代型分组密码，其分组长度固定为128 比特，密钥长度则可以是128，192或256比特 AES流程： 128、192、256比特分别为：16、24、32字节，4、6、8字（），迭代轮数分别为10、12、14（） 分组是以字节为单位的4*4方阵.按列排序： 1234a0 a4 a8 a12a1 a5 a9 a13a2 a6 a10 a14a3 a7 a11 a15 字节代替：S盒，非线性变换，输入8位，高4位为行值，低四位为列值，输出8位 行移位：第0行不动，第1.2.3行循环左移1.2.3位。经过行移位后，1列中4个元素被分布到不同的列中。 列混淆：矩阵乘法，运算范围是：。 列混淆的逆变换： 列变换也可以通过多项式计算来定义：把状态矩阵的列视为多项式， 其中要求与模数多项式互素，这样才存在逆多项式进行逆运算。 列混淆的原理：矩阵系数是码字间最大距离的编码（MDS码），这使得有良好的混淆性。经过几轮的列混淆和行移位后，所有的输出位与所有的输入位都有关。 密钥轮加：与密钥进行逐比特异或。 密钥扩展：共生成字，前4字用于和明文异或，后面每4字用于每轮的密钥轮加中。 扩展过程中，如果下标不是4的倍数，则；如果是4的倍数，则将向左循环移动一个字节，并进行字节代换，与轮常数Rcon异或。 使用轮常数消除对称性；密码密钥的差异扩散到轮密钥中的能力，即密钥的每个位能影响到轮密钥的许多位；已知部分密码密钥或部分轮密钥比特, 不能计算出许多其它轮密钥比特；足够的非线性性, 防止只从密码密钥的差分就能完全决定所有的轮密钥差分。 AES的加密和解密的轮结构顺序不同，但是逆向行移位与逆向字节代替、轮密钥加和逆向列混淆可以交换。 行移位改变顺序，字节代替改变内容，互不影响；可以将轮密钥做逆向列变换后，则可以先逆向列混淆，在与变换后的轮密钥异或。 AES的安全性：可以抵抗差分攻击和线性密码攻击，目前还不存在快于穷举攻击的攻击方式。 评价：运算均在2^8有限域上，除了查表操作外均为简单的异或和移位操作。每一轮密钥扩展中都有非线性变换，增强了密码的抗攻击能力。 7. 分组加密的工作模式 7.1 电话本模式 ECB 明文分组，每组都使用相同的密钥加密。同一明文组总产生同样的密文组。 如果最后一组不足64位，则需要填充。 适合短消息加密，应用长消息时容易受到攻击。 7.2 密文分组链接模式 CBC 加密算法的输入是当前明文分组和前一次密文分组的异或，每个密文块依赖于前面的所有明文块。 需要使用初始化向量，IV应像密钥一样被保护。需要填充。 加密时无法并行处理。解密时，从两个邻接的密文块即可得到一个明文块，因此解密过程可以被并行化。 如果传输时发生错误，则恢复的明文中只有这个块和下一块的内容发生改变。 解密时，密文中1位的变化只会改变这个块和下一块的内容改变。 加密过程为： 7.3 密文反馈模式 CFB 利用CFB（cipher feedback）模式或OFB模式可将分组对称密码转换为流密码。 不需要对消息填充，而且运行是实时的。 需要初始向量。 加密过程不能并行化，解密过程可以。 对信道错误较敏感，错误传播：1个比特密文传输错误会传播约64/j个分组。 加密过程： 、 7.4 输出反馈模式 OFB 与CFB的区别是加密算法的输出反馈到下一轮。 优点：传输过程中的比特错误不会被传播；缺点：比CFB模式更易受到对消息流的篡改攻击。 加密过程： 7.5 计数器模式 CTR CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证不产生长时间重复输出的函数，使用一个普通的计数器是最简单和最常见的做法。 不需要填充 可并行加密，可预处理（明文不参与密钥生成），加密数据块随机访问（只需要加计数器） 加密过程： 8. 伪随机数的产生和流密码 8.1 伪随机数的产生原则 随机数序列需要满足两个特征：随机性和不可预测性 随机性： 分布均匀性：0和1均匀分布 独立性：任何子序列不能由其他子序列推导出 序列是否满足分布均匀性可以检测得出，但是是否满足独立性无法检测。有一些算法可以检测出不满足独立性。 不可预测性： 序列以后的数是不可预测的。 真随机数列是不可预测的，因为各个位之间互相独立。 伪随机数序列要注意不可预测性。 真随机数：物理噪声、高质量随机数编辑成书、真随机数发生器（TRNG） 伪随机数：使用算法生成随机数，由伪随机数发生器（PRNGs）产生 伪随机数发生器（PRNG）：生产不限长度的位流，通常作为对称流密码的输入。 伪随机函数（PRF）：用于产生固定长度的伪随机数串。如对称加密的时变值。PRF的输出常为种子加一些上下文相关的特定值。 对PRNG的要求： 通用要求：输出保密性：不知道种子的敌手不能知道伪随机串。 特定要求：随机性、不可预测性、种子的特性 随机性：尽管生成的位流是确定的，但是要显示是随机的。 不可预测性：前向不可预测性、后向不可预测性 种子的特性：安全、不可预测 PRNG的设计 特意设计的PRNG算法 基于现存密码的算法，如对称分组密码、非对称密码、Hash函数等 8.2 伪随机数发生器 8.2.1 线性同余发生器 参数：m模，a乘数，c增量，X0初始值或种子 迭代算法： 评价线性同余发生器的性能： 迭代函数应该是全周期的，级重复0 - m-1之间的所有书 产生的序列应该看上去是随机的 能有效地利用32位运算器方便的实现 在计算机中，为了满足上述指标并便于运算，m一般取，c=0，a是m的一个本原根（如7^5） 线性同余算法只在初值X0的选取具有随机性，算法本身无随机性，以后的数被确定性的产生了。 如果敌手知道算法的参数，只要知道当前的一个数，就知道了后续的所有数。 敌手知道数列中的极少一部分，就可以确定出算法的参数。 可以利用内部系统时钟修正随机数数列：产生几个数后用时钟值作为种子；或者将当前时钟值加到每个随机数上。 8.2.2 BBS发生器 参数：两个大素数，，一个随机数s与n互素 算法： 1234X[0] = s ** 2 % nfor i in range(length): X[i] = X[i-1] ** 2 % n B[i] = X[i] % 2 BBS的安全性基于大整数分解的困难性，是密码安全伪随机数比特产生器 密码安全伪随机数比特产生器：以伪随机比特产生器的输出序列的前k个比特作为输入，不存在多项式时间算法，能以大于1/2的概率预测第k+1个比特。 8.3 使用分组密码的伪随机数发生器 使用分组密码CTR模式和OFB模式： ANSI X9.17：使用3个三重DES加密，输出一个64比特的伪随机数和一个64比特的新种子 8.4 流密码 伪随机数发生器的输出称为密钥流，密钥流和明文流的每一个字节进行按位异或运算，得到一个密文字节。密码系统的安全性取决于密钥流的性能。 流密码类似于一次一密，但是一次一密使用的是真正的随机数流。 一次一密密码：密钥流是完全随机序列，且密钥不重用。一次一密在唯密文攻击条件下是理论保密的，这是唯一一个能被证明是无条件安全的密码。 流密码可以分为：同步流密码和自同步流密码 同步流密码：密钥流生成器独立于明文字符。 对于明文而言，加密过程是无记忆的；解密过程要求密钥流和加密密钥流完全同步。 通信双方有相同的种子序列和初始状态，就可以产生相同的密钥。 自同步流密码：密钥流生成器与明文字符有关。 是有记忆的：时刻的密文与时刻的明文和时刻之前个明文符号有关。 有自同步能力。 明文每个字符扩散在密文多个字符中，强化了抗统计分析的能力。 8.5 线性反馈移位寄存器 LFSR 密钥发生器的组成：驱动部分（提供统计特性好的序列）和非线性组合部分（变换成密码学特性好的序列） 反馈移位寄存器是序列密码设计中常用乱源。目的是以种子密钥为序列的初态，按照确定的递推关系，产生一个周期长、线性复杂度高、统计特性好的初始乱源，然后利用密码变换，最终产生抗破译能力强的乱数序列。 一个反馈寄存器由两部分组成：移位寄存器和反馈函数。如果反馈函数、是n个变量的线性函数，则称为线性反馈移位寄存器(LFSR)。输出的序列称为线性反馈移位寄存器序列，记为LFSR序列。 把多项式f(x)称为LFSR的特征多项式 例题： 反馈移位寄存器的功能完全由其反馈逻辑函数决定。 移位寄存器的序列存在周期。能达到最长周期的序列称为m序列。 表示方法： 8.6 流密码RC4算法 RC4分为密钥调度算法（KSA）和伪随机数生成算法（PRGA） ​ KSA使用密钥生成原始S表。 ​ PRGA使用S表产生流密钥序列。 加密单位是字节。密钥长度1-256字节任意。 密钥调度算法： RC4使用了一个2^8字节大小的非线性数据表(简称S表)，对S表进行非线性变换，得到密钥流。 12345S = [i for i in range(256)]T = [k[i % len(k)] for i in range(256)]for i in range(256): j = j + S[i] + T[i] % 256 S[i], S[j] = S[j], S[i] 伪随机数生成算法： 1234567i, j = 0, 0while True: i = i + 1 % 256 j = j + S[i] % 256 S[i], S[j] = S[j], S[i] t = S[j] + S[i] % 256 k = S[t] 通过设计合适的伪随机数发生器，当密钥长度相当时，流密码可提供和分组密码一样的安全性。 对于流密码，如果用流密码对两个明文加密且使用相同密钥，则密码分析就会相当容易：如果对两个密文流进行异或，那么得出的结果就是两个原始明文的异或。 9. 公钥密码与 RSA 9.1 公钥密码原理 公钥，私钥 可提供的安全服务： 保密性：任何人可以使用公钥加密，只有私钥持有者可以用私钥解密。 不可否认性：只有私钥持有者可以使用私钥签名，任何人可以使用公钥认证。 公钥密码技术研究的基本工具不再像对称密码技术那样是代替和置换，而是数学函数。公钥密码体制的这种安全性理论基础只是基于复杂性理论的一种计算安全性。 公钥密码体制由6部分组成：明文密文、公钥私钥、加密解密算法。 公钥密码体制的主要特点是采用两个密钥将加密和解密能力分开。 使用公钥密码进行加密时，由于任何人都可以使用公钥进行加密，因此得到的密文不具有认证性，即无法确定是谁发的。因此要同时实现保密性和认证性，要采用双重加密：先用自己的私钥进行签名，再用对方公开的公钥加密后公开。 公钥密码应该满足的条件： 单向函数不能用于加密。丹恒单向陷门函数对于不知道陷门的人表现出单向函数的特性，可以用于加密。因此设计公钥密码体制变成了寻找单向陷门函数。公钥密码思想的首创者Diffie和Hellmen指出：计算复杂性中的NP完全问题可被用作设计公钥密码算法。 可提供单向函数的数学难题是： 大整数分解问题：RSA 有限域的离散对数问题：DH协议 椭圆曲线上的离散对数问题：SM2 9.2 RSA公钥算法 RSA是一种分组加密算法，明文和密文在0到n-1之间，n是一个正整数，公钥为(e,n)，私钥为(d,n) 算法的数学基础是初等数论中的Euler(欧拉)定理，并建立在大整数因子分解的困难性之上 其中包括三个算法：密钥生成算法、加密算法、解密算法 密钥生成算法： 两个不同但是大小相近的大素数p和q，n=pq，整数e满足$gcd((n),e) = 1 ，计算满足de = 1 mod (n)。则(e,n)为公钥，(d,n)$为私钥。 加密算法： 将明文M分组，使得每组的内容十进制数小于n，即分组长度小于（小于比n小的2的最大次幂）（分组大小，满足），对每组明文做运算： 解密算法： 算法的正确性证明 RSA的安全性是基于加密函数是一个陷门单向函数，陷门是分解，进而用欧式法则求出私钥d。 优点：第一个能同时用于加密和数字签名的算法，也易于理解和操作；符合计算机网络的环境；对于大量用户，可以将加密密钥用电话簿的方式印出。 缺点：产生密钥很麻烦；分组长度太大，运算代价很高，尤其是速度较慢。 9.3 RSA中的计算问题 快速模幂算法 平方和乘法将计算的模乘法数目缩小到至多，为c的二进制表示的比特数 如n以二进制表示有k比特，即，则有 因此计算可以在时间内完成。 为了提高加密速度，e可以取特定的小整数，如，或者3。但是RSA也是无法达到对称密钥的运行速度。具体应用中将RSA算法更多地用于密钥的安全传输过程，而在针对具体传输信息 的加密与解密中依靠对称密钥算法，这样便能够增进密码系统的运行速度。 解密的快速实现 密钥生成 采用概率素数判定测试(如：Miller Rabin)找到可使用的p和q 9.4 RSA的安全性分析 p和q大约是100位的十进制数，n长度不少于512比特 要很大，且pq的长度相同 p和q最好位强素数： 强素数需满足：p-1也有大的素数因子r，p+1也有大的素数因子，r-1仍有大的素数因子 9.4.1 因式分解攻击 有三种途径：分解n；能计算出；能直接确定d 转移到2048位的RSA、Diffie-Hellman或DSA密钥 9.4.2 参数选取不当造成的攻击 要很大 如果小，则也小，此时稍大于n，即稍大于 顺序检查大于的每一个数x，找到某个x使得可以被开方为y，则 9.4.3 选择密文攻击 RSA算法有同态的特点： RSA最优非对称加密填充（RSA-OAEP）可抗击适应性选择密文攻击。 9.4.4 共模攻击 不同用户之间不要共享整数n 若一个用户有一个模数n，而拥有多组不同的e和d。若存在同一信息P分别用不同的公钥加密，若e1和e2恰好互质（存在），则可以得到P： 9.4.5 小指数攻击 9.4.6 解密密钥的安全 在私钥d被泄露的情况下，整数n也不再安全，重新选择e也无法保证安全性，必须重新选择n。 计算解密密钥d的难度并不小于对整数n进行素因子分解的难度。 如果获得一个 的非平凡平方根，则可以在多项式时间内完成对n的分解。 10. 其他密码体制 10.1 Rabin密码体制 10.2 Diffie-Hellman密钥交换 10.3 ElGamal密码体制 10.4 ECC 11. 密码学Hash函数 11.1 密码学hash函数的应用 哈希函数用于将任意长的消息映射为较短的、固定长度的一个值。对于大的输入集合使用该函数，输出结果应该分布均匀且看起来随机。 Hash函数首要目标是保证数据的完整性，对于任何一位或几位的改变都将极大可能改变其hash码。 散列函数是一种单向密码体制，即它从明文到密文是不可逆映射，并且找到两个不同的数据块对应相同的Hash值在计算上不可行。 MD系列：1978年，Merkle和Damagad设计MD迭代结构。 SHA系列：SHA1、SHA2都是迭代结构。Keccak被选为SHA-3，采用了创新的“海绵引擎”散列消息文本。 国密：SM3，采用MD结构，输出值为256比特。 哈希函数在密码学中的应用：消息认证码、谁在前面、伪随机数发生器、一次性口令 在区块链中的应用：快速验证、防止篡改、POW工作量证明 消息认证： 是验证消息完整性的一种服务。确保受到的数据不变且发送方的身份有效。 方法1：AB共享一个密钥，消息与其杂凑码链接后用单钥加密算法加密 方法2：用单钥加密算法仅对杂凑码加密，这种方式用于不要求保密性的情况下，可减少处理负担 方法3：AB共享一个秘密值S，A计算消息和秘密值链接在一起的杂凑值，并将此杂凑值附加到消息后发往B 方法4：在上一种方式的基础上，在消息与杂凑值链接以后再增加单钥加密运算 方法5：用公钥加密算法，将消息和用发送方的密钥签名消息的杂凑码连接在一起 方法6：方法5之后再使用单钥加密算法加密。这种方式提供了保密性和数字签名 数字签名： 使用用户的私钥加密消息的Hash值，其它任何知道该用户公钥的人通过数字签名验证消息的完整性。 可以减少签名长度，提高签名速度；可以不泄露签名对应的信息。 11.2 安全性需求 Hash函数安全性条件：伪随机性:映射分布均匀性和差分分布均匀性 使输入中每一个比特的信息，尽量均匀地反映到输出的每一个比特上去 输出中的每一个比特，都是输入中尽可能多比特的信息一起作用的结果 01个数大致相等、雪崩效应、1个变化一半以上变化 杂凑函数的攻击：伪造消息，使其与原来消息的杂凑码相同 攻击方法：穷举攻击（原像攻击和第二原像攻击、碰撞攻击）、算法分析 评价hash算法抗密码分析能力的方法是：与穷举攻击所需的代价相比，理想的hash函数算法要求密码分析攻击所需代价大于或等于穷举攻击所需代价。 穷举攻击：不依赖于任何算法细节，仅与Hash值长度有关，包括 原像攻击和第二原像攻击：给定hash，找到这个杂凑值的消息。攻击规模是，平均尝试次 碰撞攻击：找到两个信息满足哈希值相等。两种常用的攻击方法：生日攻击法和中点交会攻击法。 第一类生日攻击： 问题：H有n个可能的输出， 是一个特定的输出，对H取k个输入，至少有一个输入y使得时，k有多大？ y取k个随机值得到函数的k个输出中至少有一个等于H(x)的概率为：。若概率等于0.5，则。当输出长为m比特时， 第二类生日攻击： 寻找函数H的具有相同输出的两个任意输入 设哈希函数输出长度为m比特，H的k个随机输入中至少有两个产生相同输出的概率大于0.5，则： 11.3 迭代型哈希函数 输入消息M分为L个长度为b位的分组（），若不能正好分组，需要填充到b的整数倍位。f为压缩函数。 Hash函数的一般结构为： 迭代技术（压缩函数f）： 由于函数的输入包含了长度，所以攻击者必须：找出具有相同的Hash值且长度相等的两条消息，或者长度不等但是加入消息长度后Hash相同的消息，增加了攻击的难度。 Merkle和Damgard已经证明：如果压缩函数是无碰撞的，则上述方法得到的Hash函数也是无碰撞的。因此Hash函数的核心是设计无碰撞的压缩函数f，要求找出f的碰撞在计算上是不可行的。 11.3.1 MD5 迭代型散列函数 输入：任意长度。分组：512比特。输出：128比特。 算法步骤： 填充，填充的第一位是1，其余为0。填充到比512的倍数少64位（），原始已经满足长度要求的数据也需要填充。 附加消息长度：将原始消息长度用64位表示，先填充低32位，后填充高32位。长度超过64位的取低64位。经过1、2步预处理后，消息长度为512的倍数，分组： 初始化缓冲区：中间结果和最终结果都保存在128位的缓冲区里。缓冲区用4个32位寄存器表示。对4个缓冲区附初始值，并以小端格式存储。 以512位的分组为单位处理消息：迭代执行压缩函数： 由四轮组成，每轮中对四个缓冲区进行16次迭代，每步迭代中使用当前512比特分组中的一个字（32比特）。 每轮中使用当前分组的16个字的顺序不一样。每轮中使用的逻辑函数g执行的位运算也不同。常数表的作用是“随机化”32位的输入数据，消除输入数据的规律性。循环左移的值与迭代的部步数和轮数都有关。加法是模相加。 输出：第L个分组处理后就是x的散列值。 安全性：MD5杂凑码中输出的每一比特是所有输入比特的函数，因此获得了很好的扩散效果。 从穷举搜索的角度，第二类生日攻击需要进行次运算，因此认为MD5容易受到第二类生日攻击。 11.3.2 SHA-1 迭代型哈希函数 输入：长度小于的消息。分组大小：512比特。输出：160比特。 算法步骤： 填充，与MD5相同 附加消息长度：用64位表示长度，并以大端存储的方式附加在后面 初始化缓冲区：中间结果和最终结果都保存在160位的缓冲区里。缓冲区用5个32位寄存器表示。对5个缓冲区附初始值，并以大端格式存储。 以512位分组为单位处理消息：压缩函数： 共四轮处理，每轮20次迭代。 分组中前16个字直接使用，后面使用计算，输入分组的16个字扩展成80个字以供压缩函数使用。基本逻辑函数执行位运算，每轮不同。加法是模相加。 输出 安全性：SHA1抗穷举攻击的能力比MD5强，并且抗密码分析的能力不弱。 11.3.3 SM3 迭代型哈希结构 分组长度：512位。输出长度：256位。 算法步骤： 填充：填充到512位的倍数，方法与MD5一样。 消息扩展：对每个分组产生132个消息字，每个消息字长32位。 迭代压缩：使用消息字进行迭代。 输出 11.4 海绵结构：SHA-3 SHA-3 第三代安全散列算法，之前名为Keccak算法。 海绵函数允许输入长度和输出长度可变。 海绵结构包括两个阶段：吸水阶段和挤压阶段。 算法流程： 填充：消息n位，被分为k个长r的分组 对长度b=r+c的状态变量s进行操作，初值设为0，在迭代中更新。默认下c=1024, r=576 吸水阶段：填充c个零，将输入从r位扩展到b位；扩展后与s进行运算，作为迭代函数f的输入，输入结果为s的新值 挤压阶段：每轮迭代中s的前r位保留作为输出分组Zi 输出：输出数据块的个数j由需要输出的位数l决定： 11.5 基于分组密码的Hash函数 CBC和CFB工作模式的特点：一个明文块的改变，在加密时会引起相应的密文块及其后的所有密文块改变。因此可利用分组密码的CBC和CFB工作模式构造Hash函数。 构造方式： 链接变量作为密钥：上一轮的输出作为下一轮的密钥 基于密码分组链接(CBC)工作模式：上一轮的输出与下一组消息异或，然后被加密 基于密码反馈(CFB)工作模式：上一轮的输出在下一轮中被加密，解密结果与这组消息进行异或 基于分组密码CBC和CFB工作模式的Hash函数中的密钥k： 若k保密，则是带密钥的Hash函数，常用于产生MAC，用于保证消息的完整性。 若k公开，则此类Hash函数是不安全的，甚至不是弱无碰撞。 11.6 基于离散对数的Hash函数 Chaum-Heijst-Pfitzmann Hash函数： 基于离散对数问题，可以证明是安全的 p是一个大素数，是一个素数，a和b是Zp的两个本原元。定义hash函数为： Chaum-Heijst-Pfitzmann Hash函数是强抗碰撞的。 证明：用反证法。若Hash函数h有一对碰撞，则可证明离散对数能被有效计算。 12. 消息认证码 12.1 对消息认证的要求 验证的内容包括： 所收到的消息确实来自真正的发送方 消息没有被修改 也可以验证消息的顺序和及时性 12.2 消息认证函数 认证符的产生有三类： 哈希函数：消息映射为定长的哈希值，以哈希值作为认证符 消息加密：对整个消息加密后的密文作为认证符 消息认证码：是消息和密钥的函数，产生定长的值 利用对称密码进行认证： 发送端：将明文消息M作为某个函数F的输入，产生帧校验序列（FCS），M和FCS连接到一起后进行加密 接收端：解密，重新利用F函数计算M的FCS，如果计算得到和收到的FCS相等，则认为消息是真实的 公钥加密：先签名再加密：提供保密性和认证性 消息认证码MAC：是指消息被一密钥控制的公开函数作用后产生的、用作认证符的、固定长度的数值。。 MAC是实现有效、安全可靠数字签字和认证的重要工具，是安全认证协议中的重要模块。 MAC算法不要求可逆性，想是带有密钥的Hash函数。但是也不是加密函数，因为MAC算法不要求可逆性，与加密函数相比，MAC函数更不容易被攻破。 12.3 MAC的安全性 攻击目的： 伪造攻击：攻击者在没有密钥的情况下，伪造一个未经认证的对 密钥恢复攻击：攻击者通过分析一系列消息、认证码对，找到控制密钥 伪造攻击 密钥恢复攻击：考虑敌手使用穷搜索攻击获取密钥 密钥有种，MAC值有种，，敌手知道多对信息和其认证码 第一轮：对于，穷举所有的密钥，由于密钥数多于MAC值的取值，因此有个密钥可能是正确的 第二轮：对于，在上述密钥中遍历，找到也满足这个式子的密钥值，得到个密钥可能是正确的 不断重复：，则平均需要a轮 因此消息认证码的穷攻击比对使用相同长度密钥的加密算法的穷搜索攻击代价更大。 穷举攻击中，攻击者有通过攻击密钥空间和攻击MAC值两种办法 攻击密钥空间： 密钥长k位，对所有可能的密钥进行计算，至少有一个密钥会产生正确的MAC，代价为 根据上述的密钥恢复攻击，可知存在一些不是正确密钥的密钥也会导致某个信息的认证码是相同的，因此需要不断重复，使用别的消息进行检查。可以证明，检查这些消息总的代价是： 攻击MAC值： 目的是对给定的消息产生其有效的MAC或者对给定的MAC产生其给定的消息 与攻击具有单向性或抗弱碰撞能力的Hash码所需的代价相同，代价为 这种攻击方式不能离线进行 MAC的构造： 用hash函数构造MAC 用分组密码构造MAC 用伪随机算法构造MAC 12.4 基础Hash函数的MAC：HMAC HMAC能提供： 消息完整性认证 信源身份认证 HMAC的设计目标： 可以不经修改直接使用现有的哈希函数 镶嵌的哈希函数可以方便的被替换 保持镶嵌的散列函数的最初性能，不因用于HMAC而使其性能降低 以简单的方式处理密钥 在对镶嵌的散列函数合理假设的基础上，易于分析HMAC用于认证时的密码强度 -&gt; 是HMAC优于其他基于散列函数的MAC的一个主要方面，HMAC在其镶嵌的散列函数具有合理密码强度的假设下，可证明是安全的。 算法描述： L：M消息分组数，b：一个分组中的比特长度，n：哈希函数的输出长度 K密钥长度左边填充0到b比特长，如果K的长度大于b，则先对K进行哈希后填充。得到K' K'与ipad异或，后面链接M的分组 哈希上面的所有分组 K'与opad异或，将上一步的哈希链接在异或值后 进行hash，输出值为HMAC HMAC的有效实现： 12345678910111213141516def sha1_hmac(key, message: bytes): # 将密钥和消息分别进行填充 if len(key) &gt; 64: key = sha1(key) key += b'\\x00' * (64 - len(key)) ipad = b'\\x36' * 64 opad = b'\\x5c' * 64 # 图中虚线的部分可以提前计算，用于作为散列函数的初值IV k_ipad = bytes([x ^ y for x, y in zip(key, ipad)]) k_opad = bytes([x ^ y for x, y in zip(key, opad)]) # 计算HMAC-SHA1值 inner_hash = sha1(k_ipad + message) outer_hash = sha1(k_opad + inner_hash) return outer_hash HMAC的安全性 HMAC的安全取决于镶嵌的哈希函数的安全性。 证明了对HMAC的攻击等价于对内嵌散列函数的下述两种攻击之一： 攻击者能够计算压缩函数的一个输出，即使IV是随机的和秘密的。 攻击者能够找出散列函数的碰撞，即使IV是随机的和秘密的。 13. 数字签名 14. 密钥的管理和分发 14.1 密钥管理 密钥管理原则： 攻击者无法窃取 即使窃取到了也无法使用（超过使用时间和范围限制） 密钥的分配和更新对用户透明 密钥产生： 长度应该足够 密钥生成算法要足够安全：密钥生成算法的安全性不应低于密码算法的安全性 避免使用弱密钥，应使用长密钥 密钥生成算法： 非线性密钥空间：算法生成的密钥的强度不一致 线性密钥空间：密钥强度一致 防止我方黑盒密码设备被敌方利用： 密钥分为前后两部分，前一部分是密钥，后一部分是一个固定值用该密钥加密后得到的字符串 设备执行时，先解密后面的字符串，若匹配则正常。若不匹配，使用另外一个弱算法。 密钥128位，识别串64位，随机选取一个得到好密钥的概率是 密钥验证：确认来自正确的人；确认密钥没有传输错误（附带一个用该密钥加密的密文） 密钥更新：用旧密钥计算、用旧密钥协商，新密钥的安全性不会超过旧密钥。重新认证身份并分发密钥。旧密钥必须销毁。 14.2 基于对称加密的对称密钥分发 两个用户使用单钥密钥体制的时候，必须先共享一个密钥，还需要经常更新密钥。 密码系统的强度也依赖于密钥分配技术。 密钥分配的基本方法： 密钥由A选取并通过物理手段发送给B 密钥由第三方选取并通过物理手段发送给AB 如果AB事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方。 缺点：攻击者一旦获得一个密钥就可获取以后所有的密钥，同时用这种方法对所有用户分配初始密钥时，代价仍然很大。 如果AB与第三方分别有一保密信道，则第三方选取密钥后，分别在两个保密信道上发送给AB 第四种方法比较常用，其中的第三方通常是一个负责为用户分配密钥的密钥分配中心(KDC)。这时每一用户必须和密钥分配中心有一个共享密钥，称为主密钥。通过主密钥分配给一对用户的密钥称为会话密钥，通信完成后，会话密钥即被销毁。主密钥可通过物理手段发送。 密钥分配的具体过程： A向KDC发送 Request 和 N1（这次业务的唯一标识符，是一个随机数，防止重放和篡改） KDA返回一个由（A保存的主密钥的）加密的信息，保证只有A能解密。解密信息包括：，Request，N1， A得到会话密钥。并向B转发最后一项的内容。由于最后一项是由B的主密钥加密的，因此只有B可以解密。并且可以获取会话密钥和对话的另一方的ID B用会话密钥加密一个随机数N2发给A A以f(N2)返回作为对B的应答，f函数可以是对N2加一等操作。 45两步可以让B相信第三步收到的消息不是一个重放。第三步已经完成了密钥分配，45两步还完成了认证的功能。 密钥的分层控制： 网络中如果用户数目非常多且分布的地域非常广，则需要使用多个KDC的分层结构 分层结构可减少主密钥的分布，还可将虚假KDC的危害限制到一个局部区域，但会降低信任度 分布式密钥控制： 在上述方法中需要所有用户都信任KDC，还需要对KDC加以保护。如果密钥分配是无中心的，则可以不需要KDC，但是主密钥多达个。 在整个网络的局部范围却非常有用 密钥的控制使用： 主密钥：密钥加密密钥。会话密钥：数据加密密钥。 如果主密钥泄露了，则相应的会话密钥也将泄露，因此主密钥的安全性应高于会话密钥的安全性。 会话密钥的有效期： 会话密钥更换得越频繁，系统的安全性就越高。 会话密钥更换得太频繁，又将延迟用户之间的交换。 14.3 基于非对称加密的对称密钥分发 公钥用于分配单钥密码体制的密钥非常合适。 简单分配流程： 公钥缺少证书管理机构认证且非物理传输中容易受到中间人攻击。 具有保密性和认证性的密钥分配： 假定AB双方已完成公钥交换，则可按以下步骤建立共享会话密钥： 14.4 公钥分发 公开发布 公用目录表 公钥授权 优点：每次密钥的获得由公钥管理机构查询并认证发送，用户不需要查表，提高了安全性 缺点：公钥管理机构必须一直在线，由于每一用户要想和他人联系都需求助于管理机构，所以管理机构有可能成为系统的瓶颈。由管理机构维护的公钥目录表也易被敌手通过一定方式窜扰。 公钥证书 用户通过公钥证书来互相交换自己的公钥而无须与公钥管理机构联系 公钥证书由证书管理机构CA(certificate authority)为用户建立 A 将自己的公钥发给CA，CA返回A的公钥证书 X.509认证服务 证书机构Y颁发给用户A的证书表示为：。 V是版本号，SN是证书序号，AI是证书算法标识，CA是发行者，TA是有效期，A是用户信息，AP是A的公钥 任何可以访问CA的用户都可以得到一个证书，只有CA可以修改证书。由于证书用CA的私钥签名，不能伪造，因此可以放在一个公共目录中。 不共享同一CA的用户获得证书： 两个CA之间已经交换了公开密钥，含有对方的证书。则A可以先读取，获取X2的公钥后，在读取，读取B的公钥。 这个证书链可以表示为： 证书的撤销：每一个证书都具有一个有效期，有效期结束时证书将自动撤销。也可以在有效期结束前撤销。为了有效的管理证书的撤销，CA会维护一个证书撤销列表CRL。当用户获取一个证书时，应检查CA的CRL，判断该证书是否已被撤销。 14.5 公钥基础设施（PKI） 为管理公钥（生成、认证、存储、安装），须建立一套公钥基础设施（PKI，Public Key Infrastructure），PKI的基本组成元素是证书颁发机构（CA，Certificate Authority）。 PKI主要完成的工作为： 为用户生成一对密钥（公开密钥，私有密钥），并通过一定的途径分发给用户。 CA为用户签发数字证书，形成用户的公开密钥信息，并通过一定的途径分发给用户。 对用户证书的有效性进行验证。 对用户的数字证书进行管理。这些管理包括有效证书的公布、撤销证书的公布、证书归档等。 PKI包含五个关键元素： 端实体：一个在公钥数字证书作用范围中被认证的实体。 签证机构CA：证书和证书撤销列表的发行人。 注册机构RA：可选元素，承担一些签证机构（CA）的管理任务。 证书撤销列表发布点：可选元素，CA可通过它来发布证书撤销列表（CRL）。 证书存取库：必备元素，提供存取数字证书和证书撤销列表的方法。","link":"/2023/06/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"计算机网络期末复习","text":"第一章、计算机网络概述 1.1 互联网概述 计算机网络的四个发展阶段： 面向终端的计算机网络： 第一阶段的缺点： 主机通信开销大，通信线路利用率低，对主机系统依赖性较大。规模小，终端数量少。 多台计算机互连的计算机网络：提出分组交换技术、形成TCP/IP协议雏形 分组交换网络的基本要求： 网络侧重于计算机之间的数据传送 网络能够连接不同类型的计算机 计算机在进行通信时，必须有冗余的路由 网络的结构应当尽可能地简单，同时还能够非常可靠地传送数据 分组交换网和面向终端的计算机的网络的区别： 分组交换网是以网络为中心，主机处在网络的外围 面向终端的网络是以单个主机位中心的星形网 第二阶段的缺点： 没有形成统一的互连标准，使网络在规模与应用等方面受到了限制、 面向标准化的计算机网络：形成网络体系结构、TCP/IP结构、形成各种标准 ISO/OSI-RM国际标准，该模型按层次结构将网络划分为七个子层 形成了以TCP/IP为核心的因特网。任何一台计算机只要遵循TCP/IP协议族标准，并有一个合法的IP地址，就可以接入到Internet。 面向全球互连的计算机网络： 1.2 互联网的组成 计算机网络：是互连的、自治的计算机集合。自治：指网络中无主从关系。 主机（hosts）是端系统，运行各种网络应用程序。 网络协议（network protocol），是为进行网络中的数据交换而建立的规则、标准或约定；协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”。协议规范了网络中所有信息发送和接收过程。 协议的三要素：语法、语义、同步 计算机网络结构： 网络边缘：主机、客户/服务器模型（client/server）、对等应用模型（P2P） 接入网络：有线或无线通信链路 网络核心：网络的核心功能：路由和转发 路由：确定分组从源到目的传输路径 转发：将分组从路由器的输入端口交换至正确的输出端口 如何实现数据从源主机通过网络核心送达目的主机？数据交换 数据交换技术： 电路交换： 在通信之前，需要在主、被叫用户之间建立一条物理连接 采用了静态的时分复用，独占资源 没有任何差错控制措施 报文交换： 采用存储－转发方式对每份报文完整地加以处理 每份报文中含有报头，包含收、发双方的地址，以便交换节点进行路由选择 存储-转发的时延大，随机性也大 分组交换： 在发送端，先把较长的报文划分成较短的、固定长度的数据段。每一个数据段前面添加上首部构成分组 分组交换网以分组作为数据传输单元。依次把各分组发送到接收端 每一个分组的首部都含有地址，交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。 每个分组在互联网中独立地选择传输路径。 接收端收到分组后剥去首部还原成部分报文，最后所有报文连接起来恢复成原来的报文。 分组交换的优点： 在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用 每一个分组独立地选择最合适的转发路由 以分组作为传送单位，可以不先建立连接就能向其他主机发送分组 保证可靠性的网络协议 分组交换的问题： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部，会造成额外的开销。 互联网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在互联网的边缘部分。核心部分中的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 1.3 计算机网络的类别 计算机网络的定义： 计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。 注：上述的“可编程的硬件”表明这种硬件一定包含有中央处理机 (CPU)。 用来把用户接入到互联网的网络，为接入网AN，接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。 1.4 计算机网络的性能 1.4.1 性能指标 速率 单位时间（秒）传输信息（比特）量 单位：、、 带宽 数字信道所能传送的“最高数据率” 延迟/时延 延迟：正在等待排队的分组、正在传输的分组 丢包：路由器缓存满、到达分组被丢弃 结点处理延迟 ：用于差错检测、确定输出链路 排队延迟 传输/发送延迟 分组长度传输速率，是分组发送出端口的时间 传播延迟 物理链路长度信号传输速度，是分组在物理线路上传播的时间 延迟时间是上面四者的和 流量强度：，R链路传输速率，L分组长度，a平均分组到达速率。流量强度接近0表示平均排队延迟很小，接近1表示延迟很大，大于1表示超出服务能力、平均延迟无限大。 时延带宽积 = 传播时延 × 带宽。表示以比特为单位的链路长度 丢包率 = 丢包数 ÷ 已发分组数 吞吐量 在发送端与接收端之间数据传输速率 瓶颈链路：端到端路径上，限制端到端吞吐量的链路。即吞吐量的最小值 往返时间RTT 往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率 分为信道利用率和网络利用率。 网络利用率则是全网络的信道利用率的加权平均值。 信道利用率增大时，该信道的时延迅速增大。 1.4.2 非性能指标 包括质量、费用、可靠性等等 1.5 计算机网络的体系结构 是分层结构 计算机网络体系结构是计算机网络的功能层次、其关系及其协议的集合，是抽象的。 协议： 协议是控制两个对等实体进行通信的规则的集合。 协议控制两个对等实体之间的通信使得本层能够向上一层提供服务。 协议是水平的。 要实现某层的协议，还需要使用下面一层所提供的服务。 服务： 任意一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务。 服务是垂直的。 下层协议的实现对上层的服务用户是透明的。 接口：又称服务访问点，从物理层开始，每一层都向上层提供服务访问点，即没有接口就不能提供服务。 相邻层之间是通过接口进行交互的，通过服务访问点SAP，交换服务原语，请求特定服务。 数据封装：增加控制信息 地址: 标识发送端/接收端 差错检测编码 协议控制 OSI7层模型各层次的功能： 物理层 接口特性 比特编码 数据率、比特同步 传输模式：单工、半双工、全双工 数据链路层 负责结点-结点数据传输 组帧（开头结尾加DT和DH） 物理寻址：发送和接收端物理地址的标志 流量控制、差错控制、访问控制 网络层 负责源主机到目的主机数据分组交付 逻辑寻址：全局唯一逻辑地址，确保数据送达目的主机，例如IP地址 路由和转发功能 传输层 负责源主机到目的主机进程间（端到端）的完整的报文传输 分段和重组功能 SAP服务访问点寻址：提交给正确的进程 流量控制、差错控制、连接控制 会话层 对话控制 同步 最薄的一层 表示层 数据表示转化、数据编码 加密、解密 压缩、解压缩 应用层 用户通过网络接口使用网络 文件传输FTP、web HTTP、邮件SMTP等等 路由器在转发分组的时候最高只用到网络层，不使用传输层和应用层。 TCP/IP四层体系：应用层、运输层、网际层和网络接口层。 因此往往采取折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。 应用层: 支持各种网络应用：FTP, SMTP, HTTP 传输层: 进程-进程的数据传输：TCP, UDP 网络层: 源主机到目的主机的数据分组路由与转发：IP协议、路由协议等 链路层: 相邻网络元素（主机、交换机、路由器等）的数据传输：以太网（Ethernet）、802.11 (WiFi)、 PPP 物理层: 比特传输 信息在源主机从应用层逐层封装一直到物理层 在交换机经过物理层和链路层处理 在路由器经过物理层、链路层和网络层处理 最后到达目的主机从物理层逐层向上到达应用层 第二章、物理层 2.1 物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的主要确定： 机械特性 电气特性 功能特性 过程特性 2.2 数据通信的基础知识 一个数据通信系统包括三部分：源系统（发送方）、传输系统、目的系统（接收方） 2.2.1 一些概念： 数据：预先约定的具有某种含义的数字、字母和符号的组合，是运送消息的实体。 信号：数据的电气或者电磁的体现。 模拟数据：表示在某个区间产生的值是连续的。 数字数据：是离散的值。 模拟信号：代表消息的参数的取值是连续的，是一种连续变化的电磁波。 数字信号：代表消息的参数的取值是离散的，是一系列的电压脉冲。 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 3-&gt;5放大器调制器、 3-&gt;6PCM编码器、 4-&gt;5调制器、 4-&gt;6数字发送器 基带信号：数字信号直接使用两种不同的电压表示后，在数字信道上传输，称为基带传输。 宽带信号：基带信号调制成模拟信号后在模拟信道上传输，称为宽带传输。 调制：模拟数据或者数字数据转换成模拟信号的过程。 数字调制：数字数据调制为模拟信号。 数字调制的两种方式：带通调制、基带调制。 带通调制：使用载波进行调制，把基带信号转换为模拟信号。一般采用三种方式：调幅、调频、调相 基带调制：仅对基带信号的波形进行变换，得到的仍是基带信号。这个过程称为编码。 模拟调制：模拟数据调制为模拟信号。 单工通信：单向通信 半双工通信：双向交替通信 全双工通信：双向同时通信 2.2.2 带通调制和基带调制 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须基信号进行调制。 带通调制中基本的调制方法： 调幅：振幅 调频：频率 调相：初始相位 正交振幅调制QAM：更为复杂的多元制的振幅相位混合调制 如果一个码元表示的比特数越多、在接收端进行解调时正确识别每一种状态就越困难，出错率增加。 基带调制中常用的编码方式： 不归零制：用电平 归零制：用脉冲 曼彻斯特编码：位周期中心跳变。位周期中心的向下跳变代表1，位周期中心的向上跳变代表0。 差分曼彻斯特编码：位开始跳变。在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。 不归零制不能区分周期和频率，因此没有自同步能力。曼切斯特编码和其差分有自同步能力。 2.2.3 信道容量 信道容量是指，在一定条件下，指定信道上能达到的最大数据传输速率。 数据传输速率： 传码速率、波特率：每秒传输信号码元的个数，单位是波特。 传输速率、比特率：每秒传输二进制码元的个数，单位是 奈氏准则：在理想条件下，一个无噪声、带宽为W赫兹的信道，其传码速率最高是 波特。则极限的传输速率为：（M为电平数） 限制码元在信道上传输速率的因素有：信道能够通过的频率范围、信噪比 具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 信噪比：是信号的平均功率和噪声的平均功率之比： 信噪比 噪声的影响是相对的。如果信号较强，则信噪比的影响就较弱。 香农推导出了带宽受限且有高斯白噪声干扰的信道极限、无差错的信息传输速率： 香农公式表明，只要信息传输速率低于信道的极限传输速率，就一定可以找到某种方法实现无差错的传输。 但是在和已经确定的信道上，还可以通过编码的方法使得每个码元携带更多比特的信息量。 2.3 物理层下面的传输媒体","link":"/2023/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"大二上","slug":"大二上","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8A/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"大二下","slug":"大二下","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[]}