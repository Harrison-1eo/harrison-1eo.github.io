{"pages":[{"title":"","text":"Harrison-1eo (Harrison) (github.com)","link":"/links/index.html"},{"title":"","text":"I'm Harrison-1eo An undergraduate student at the School of Cyberspace Security of Beihang University If you have any questions, welcome to contact me via email. 😊😊😊😁😁😁😋😋😋 😎😎😎🤗🤗🤗🤩🤩🤩 😝😝😝🫣🫣🫣🥺🥺🥺","link":"/about/index.html"}],"posts":[{"title":"计算机网络期末复习","text":"第一章、计算机网络概述 1.1 互联网概述 计算机网络的四个发展阶段： 面向终端的计算机网络： 第一阶段的缺点： 主机通信开销大，通信线路利用率低，对主机系统依赖性较大。规模小，终端数量少。 多台计算机互连的计算机网络：提出分组交换技术、形成TCP/IP协议雏形 分组交换网络的基本要求： 网络侧重于计算机之间的数据传送 网络能够连接不同类型的计算机 计算机在进行通信时，必须有冗余的路由 网络的结构应当尽可能地简单，同时还能够非常可靠地传送数据 分组交换网和面向终端的计算机的网络的区别： 分组交换网是以网络为中心，主机处在网络的外围 面向终端的网络是以单个主机位中心的星形网 第二阶段的缺点： 没有形成统一的互连标准，使网络在规模与应用等方面受到了限制、 面向标准化的计算机网络：形成网络体系结构、TCP/IP结构、形成各种标准 ISO/OSI-RM国际标准，该模型按层次结构将网络划分为七个子层 形成了以TCP/IP为核心的因特网。任何一台计算机只要遵循TCP/IP协议族标准，并有一个合法的IP地址，就可以接入到Internet。 面向全球互连的计算机网络： 1.2 互联网的组成 计算机网络：是互连的、自治的计算机集合。自治：指网络中无主从关系。 主机（hosts）是端系统，运行各种网络应用程序。 网络协议（network protocol），是为进行网络中的数据交换而建立的规则、标准或约定；协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”。协议规范了网络中所有信息发送和接收过程。 协议的三要素：语法、语义、同步 计算机网络结构： 网络边缘：主机、客户/服务器模型（client/server）、对等应用模型（P2P） 接入网络：有线或无线通信链路 网络核心：网络的核心功能：路由和转发 路由：确定分组从源到目的传输路径 转发：将分组从路由器的输入端口交换至正确的输出端口 如何实现数据从源主机通过网络核心送达目的主机？数据交换 数据交换技术： 电路交换： 在通信之前，需要在主、被叫用户之间建立一条物理连接 采用了静态的时分复用，独占资源 没有任何差错控制措施 报文交换： 采用存储－转发方式对每份报文完整地加以处理 每份报文中含有报头，包含收、发双方的地址，以便交换节点进行路由选择 存储-转发的时延大，随机性也大 分组交换： 在发送端，先把较长的报文划分成较短的、固定长度的数据段。每一个数据段前面添加上首部构成分组 分组交换网以分组作为数据传输单元。依次把各分组发送到接收端 每一个分组的首部都含有地址，交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。 每个分组在互联网中独立地选择传输路径。 接收端收到分组后剥去首部还原成部分报文，最后所有报文连接起来恢复成原来的报文。 分组交换的优点： 在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用 每一个分组独立地选择最合适的转发路由 以分组作为传送单位，可以不先建立连接就能向其他主机发送分组 保证可靠性的网络协议 分组交换的问题： 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部，会造成额外的开销。 互联网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在互联网的边缘部分。核心部分中的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 1.3 计算机网络的类别 计算机网络的定义： 计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。 注：上述的“可编程的硬件”表明这种硬件一定包含有中央处理机 (CPU)。 用来把用户接入到互联网的网络，为接入网AN，接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。 1.4 计算机网络的性能 1.4.1 性能指标 速率 单位时间（秒）传输信息（比特）量 单位：、、 带宽 数字信道所能传送的“最高数据率” 延迟/时延 延迟：正在等待排队的分组、正在传输的分组 丢包：路由器缓存满、到达分组被丢弃 结点处理延迟 ：用于差错检测、确定输出链路 排队延迟 传输/发送延迟 分组长度传输速率，是分组发送出端口的时间 传播延迟 物理链路长度信号传输速度，是分组在物理线路上传播的时间 延迟时间是上面四者的和 流量强度：，R链路传输速率，L分组长度，a平均分组到达速率。流量强度接近0表示平均排队延迟很小，接近1表示延迟很大，大于1表示超出服务能力、平均延迟无限大。 时延带宽积 = 传播时延 × 带宽。表示以比特为单位的链路长度 丢包率 = 丢包数 ÷ 已发分组数 吞吐量 在发送端与接收端之间数据传输速率 瓶颈链路：端到端路径上，限制端到端吞吐量的链路。即吞吐量的最小值 往返时间RTT 往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率 分为信道利用率和网络利用率。 网络利用率则是全网络的信道利用率的加权平均值。 信道利用率增大时，该信道的时延迅速增大。 1.4.2 非性能指标 包括质量、费用、可靠性等等 1.5 计算机网络的体系结构 是分层结构 计算机网络体系结构是计算机网络的功能层次、其关系及其协议的集合，是抽象的。 协议： 协议是控制两个对等实体进行通信的规则的集合。 协议控制两个对等实体之间的通信使得本层能够向上一层提供服务。 协议是水平的。 要实现某层的协议，还需要使用下面一层所提供的服务。 服务： 任意一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务。 服务是垂直的。 下层协议的实现对上层的服务用户是透明的。 接口：又称服务访问点，从物理层开始，每一层都向上层提供服务访问点，即没有接口就不能提供服务。 相邻层之间是通过接口进行交互的，通过服务访问点SAP，交换服务原语，请求特定服务。 数据封装：增加控制信息 地址: 标识发送端/接收端 差错检测编码 协议控制 OSI7层模型各层次的功能： 物理层 接口特性 比特编码 数据率、比特同步 传输模式：单工、半双工、全双工 数据链路层 负责结点-结点数据传输 组帧（开头结尾加DT和DH） 物理寻址：发送和接收端物理地址的标志 流量控制、差错控制、访问控制 网络层 负责源主机到目的主机数据分组交付 逻辑寻址：全局唯一逻辑地址，确保数据送达目的主机，例如IP地址 路由和转发功能 传输层 负责源主机到目的主机进程间（端到端）的完整的报文传输 分段和重组功能 SAP服务访问点寻址：提交给正确的进程 流量控制、差错控制、连接控制 会话层 对话控制 同步 最薄的一层 表示层 数据表示转化、数据编码 加密、解密 压缩、解压缩 应用层 用户通过网络接口使用网络 文件传输FTP、web HTTP、邮件SMTP等等 路由器在转发分组的时候最高只用到网络层，不使用传输层和应用层。 TCP/IP四层体系：应用层、运输层、网际层和网络接口层。 因此往往采取折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。 应用层: 支持各种网络应用：FTP, SMTP, HTTP 传输层: 进程-进程的数据传输：TCP, UDP 网络层: 源主机到目的主机的数据分组路由与转发：IP协议、路由协议等 链路层: 相邻网络元素（主机、交换机、路由器等）的数据传输：以太网（Ethernet）、802.11 (WiFi)、 PPP 物理层: 比特传输 信息在源主机从应用层逐层封装一直到物理层 在交换机经过物理层和链路层处理 在路由器经过物理层、链路层和网络层处理 最后到达目的主机从物理层逐层向上到达应用层 第二章、物理层 2.1 物理层的基本概念 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的主要确定： 机械特性 电气特性 功能特性 过程特性 2.2 数据通信的基础知识 一个数据通信系统包括三部分：源系统（发送方）、传输系统、目的系统（接收方） 2.2.1 一些概念： 数据：预先约定的具有某种含义的数字、字母和符号的组合，是运送消息的实体。 信号：数据的电气或者电磁的体现。 模拟数据：表示在某个区间产生的值是连续的。 数字数据：是离散的值。 模拟信号：代表消息的参数的取值是连续的，是一种连续变化的电磁波。 数字信号：代表消息的参数的取值是离散的，是一系列的电压脉冲。 码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 3-&gt;5放大器调制器、 3-&gt;6PCM编码器、 4-&gt;5调制器、 4-&gt;6数字发送器 基带信号：数字信号直接使用两种不同的电压表示后，在数字信道上传输，称为基带传输。 宽带信号：基带信号调制成模拟信号后在模拟信道上传输，称为宽带传输。 调制：模拟数据或者数字数据转换成模拟信号的过程。 数字调制：数字数据调制为模拟信号。 数字调制的两种方式：带通调制、基带调制。 带通调制：使用载波进行调制，把基带信号转换为模拟信号。一般采用三种方式：调幅、调频、调相 基带调制：仅对基带信号的波形进行变换，得到的仍是基带信号。这个过程称为编码。 模拟调制：模拟数据调制为模拟信号。 单工通信：单向通信 半双工通信：双向交替通信 全双工通信：双向同时通信 2.2.2 带通调制和基带调制 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须基信号进行调制。 带通调制中基本的调制方法： 调幅：振幅 调频：频率 调相：初始相位 正交振幅调制QAM：更为复杂的多元制的振幅相位混合调制 如果一个码元表示的比特数越多、在接收端进行解调时正确识别每一种状态就越困难，出错率增加。 基带调制中常用的编码方式： 不归零制：用电平 归零制：用脉冲 曼彻斯特编码：位周期中心跳变。位周期中心的向下跳变代表1，位周期中心的向上跳变代表0。 差分曼彻斯特编码：位开始跳变。在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。 不归零制不能区分周期和频率，因此没有自同步能力。曼切斯特编码和其差分有自同步能力。 2.2.3 信道容量 信道容量是指，在一定条件下，指定信道上能达到的最大数据传输速率。 数据传输速率： 传码速率、波特率：每秒传输信号码元的个数，单位是波特。 传输速率、比特率：每秒传输二进制码元的个数，单位是 奈氏准则：在理想条件下，一个无噪声、带宽为W赫兹的信道，其传码速率最高是2W波特。则极限的传输速率为：（M为电平数） 限制码元在信道上传输速率的因素有：信道能够通过的频率范围、信噪比 具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 信噪比：是信号的平均功率和噪声的平均功率之比： 信噪比 噪声的影响是相对的。如果信号较强，则信噪比的影响就较弱。 香农推导出了带宽受限且有高斯白噪声干扰的信道极限、无差错的信息传输速率： 香农公式表明，只要信息传输速率低于信道的极限传输速率，就一定可以找到某种方法实现无差错的传输。 但是在和已经确定的信道上，还可以通过编码的方法使得每个码元携带更多比特的信息量。 2.3 物理层下面的传输媒体","link":"/2023/05/31/%E8%AE%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"python 基础语法","text":"第一章 python简介 第二章 python基础语法 2.1 简单输出 12print(666)print([输出项1,输出项2,...] [,sep=分隔符] [,end=结束符]) 默认分隔符为空格，结束符为换行符 2.2 注释 使用 # 表示单行注释 使用 \"\"\" 表示多行注释 2.3 变量 变量是没有类型的，但是变量存储的数据是有类型的 可以使用 type() 查看变量类型 123456money = 50print(\"我还有\", money, \"块钱\")print(type(money))type_int = type(money)print(type_int)print(type(type_int)) 输出结果为 1234我还有 50 块钱&lt;class 'int'&gt;&lt;class 'int'&gt;&lt;class 'type'&gt; 2.4 数据类型显式转换 可以使用 int(x) float(x) str(x) 转换成相应的数据类型 注意 任何类型都可以转换成字符串类型，但是转换为int和float类型之前需要确保能转换到相应的类型 2.5 运算符 常用运算符 + - * / % // 两个斜杠为取整除,即只保留结果的整数部分 ** 两个星号为幂运算 1234print(9//2)print(9.0//2.0)print(3**2)# 输出结果为4 4.0 9 not：取反运算符 and：与运算符 or 或运算符 成员运算符 - in：在指定序列中找到指定的值则返回True，否则返回False - not in 身份运算符 - is：判断两个标识符是否引用了同一个对象 - not is 2.6 字符串 字符串定义法：单引号，双引号，三引号（可以换行） 字符串内部可以使用转义字符 \\ 来输出引号 可以使用加号（+）来对字符串进行拼接，但是不用拼接其他类型的变量,需要转换成字符串类型 ### 字符串格式化表示法 形式类似于c语言中printf括号中的内容 123massage = \"第%d个苹果重%.2f%s\" % (3, 1.2, \"kg\")print(massage)# 输出结果：第3个苹果重1.20kg 此处类似于%5.4f格式的效果与C语言相同 注意，在本格式化表示方法中，小数会自动在后面添加若干个0 字符串快速格式化 f\"内容{变量}\"的格式来快速格式化 123money = 1.2massage = f\"我有{money}这么多钱\"# 输出结果：我有1.2这么多钱 此种方法不需要进行精度处理，数字内容不变，小数位数也不变 2.7 input语句 使用 input() 语句可以从键盘获取输入 使用一个变量接收（存储）input语句获取的键盘输入数据即可 无论输入的数据是什么，都是存储为string类型的 第三章 Python判断语句 3.1 布尔类型和比较运算符 bool类型表示真和假 True 为真，为 1 False 为假，为 0 比较运算符与C语言相同，注意，==表示判断是否相等 3.2 if语句 语法格式： 123456789if 条件： 语句1elif 条件2： 语句2elif 条件3： 语句3...else： 语句N 注意，一定要进行缩进，python通过缩进的对齐判断语句的归属 条件判断语句的结果一定是bool类型的结果 第四章 Python循环语句 4.1 while循环 语法格式： 1234while 条件： 语句1 语句2 ... ## 4.2 for循环 - while循环的循环条件是自定义的，自行控制循环条件 - for循环是一种”轮询”机制，是对一批内容进行”逐个处理”将数据集中的每一个内容取出来进行处理。for循环是无法定义循环条件的，只能从数据集中依次取出内容 语法格式： 12for 临时变量 in 待处理数据集: 循环满足条件时执行的代码 例如： 12345name = \"itheima\"# for循环处理字符串for x in name: print(x)# 运行结果为将字符串中字符一个一个拿出来输出 语法格式中\"待处理数据集\"实际上为一个序列类型，其中包括字符串，列表，元组等等 通过range语句可以获得一个简单的数字序列，用于for循环中 range(num) 为从0到num的数字序列(不包含num本身) range(num1,num2) 为从num1到num2的数字序列(不包含num2本身) range(num1,num2,step) 为从num1到num2的数字序列(不包含num2本身)，步长为step 临时变量在编程规范上，作用范围（作用域）只限定在for循环内部 如果在for循环外部访问临时变量： 实际上是可以访问到的。但是在编程规范上，是不允许、不建议这么做的 4.3 continue和break 在嵌套循环中，只能作用在所在的循环上，无法对上层循环起作用 4.4 pass pass是空语句，不执行任何操作，一般用作占位语句，保持程序的完整性 第五章 Python函数基础 5.1 函数的基本定义 123def 函数名(传入参数)： 函数体 return 返回值 应先定义函数，后调用函数 参数不需要，可以省略 返回值不需要，可以省略 可以在def一行下面采用多行注释的方式写该函数的说明文档 5.2 None类型 Python中有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt; 无返回值的函数，实际上就是返回了：None这个字面量 None表示：空的、无实际意义的意思 return None，效果等同于不写return语句 在if判断中，None等同于False 一般用于在函数中主动返回None，配合if判断做相关处理 用于声明无内容的变量上 定义变量，但暂时不需要变量有具体值，可以用None来代替，例如name = None 5.3 局部变量与全局变量 在某一函数体内的为局部变量，只能在该函数体内生效 使用 global 关键字可以在函数内部声明全局变量 第六章 Python数据容器 6.1 list 列表 列表的特点： - 可以容纳多个元素（上限为2**63-1个） - 可以容纳不同类型的元素（混装） - 数据是有序存储的（有下标序号） - 允许重复数据存在 - 可以修改（增加或删除元素等） 6.1.1 列表的定义 12345# 定义变量变量名称 = [元素1, 元素2, ...]#定义空列表变量名称 = []变量名称 = list() 以 [] 作为表示，列表内每个元素之间以 , 隔开 列表可以一次存储多个数据，并且可以是不同的数据类型，支持嵌套 6.1.2 列表的下标索引 从头开始第一个的索引为0，一直到最后，如 list[2] 从尾开始最后一个的索引是-1，一直到最前 如果是列表嵌套列表，则可以使用类似C语言二位数组的表达方式，如 list[1][2] 要注意下标索引的取值范围，超出范围无法取出元素，并且会报错 6.1.3 列表的常用方法 在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法 方法的使用格式为 对象.方法(传入参数) 方法 作用 列表.index(元素) 查找指定元素在列表的下标找不到报错ValueError 列表[下标] = 值 修改特定位置的值 列表.insert(下标, 元素) 在指定的下标位置，插入指定的元素 列表.append(元素) 将指定元素，追加到列表的尾部 列表.extend(其它数据容器) 将其它数据容器的内容取出，依次追加到列表尾部 del 列表[下标] 删除列表指定下标元素 列表.pop(下标) 删除列表指定下标元素 列表.remove(元素) 从前向后，删除此元素第一个匹配项 列表.clear() 清空列表 列表.count(元素) 统计此元素在列表中出现的次数找不到报错ValueError len(列表) 统计容器内有多少元素 6.2 tuple 元组 元组的特点： - 有序、任意数量元素、允许重复元素 - 不可修改 元组内容不可以直接修改，会报错 如果元组内部有列表元素，列表中的内容可以修改 6.2.1 列表的定义 12345# 定义元组变量名称 = (元素1, 元素2, ...)#定义空元组变量名称 = ()变量名称 = tuple() 如果定义的元组只有一个元素时，在元素1后面要加一个逗号，例如 (1,)，不然则不是元组类型 6.2.2 元组的下标索引 写法与列表相同，索引从0开始计算 6.2.3 元组的常用方法 元组.index() 元组.count() len(元组) 实际效果见6.1.3表格 6.3 str 字符串 字符串的特点： - 只可以储存字符串，长度任意 - 不可修改，如果要修改，只能得到一个新的字符串 6.3.1 字符串的下标索引 类似于C语言中字符数组，可以通过下标索引取出字符，索引从0号开始计算，但是没有最后的‘\\0’占位符 6.3.2 字符串的常用方法 str.index(参数)参数可以是一个字符，也可以是一个字符串 str.replace(m,n)将字符串中的m字符串替换为n字符串，返回一个新的字符串 str.split(分隔符)按照指定的分割符将字符串分为多个字符串，返回一个列表对象 str.strip(参数)去除字符串前后的参数中的内容，注意是按照字符去除，而不是整体的字符串匹配。如果不传入参数则默认去除字符串前后的空格和换行 str.count(参数) len(str) 6.4 序列的切片 序列是指能用下标索引的容器，例如：列表、元组、字符串 切片：从一个序列中取出一个子序列 语法：序列[起始下标：结束下标：步长]，返回一个新的序列 结束下标表示到某位结束，不包含结束位 起始下标留空表示从头开始，结束下标留空表示截取到结尾 步长可以为正数，也可以为负数，表示反向取，主要这时起始下标和结束下标也要反向标记 str[::-1]相当于将字符串从尾到头倒序输出 6.5 set 集合 集合的特点： - 无序，不支持下标索引访问 - 可以修改 - 数据不能重复 - 可以容纳多个数据，不同的数据类型 6.5.1 集合的定义 1234# 定义集合变量名称 = {元素1, 元素2, ...}#定义空集合变量名称 = set() 6.5.2 集合的常用方法 set.add(ele) set.remove(ele) set.pop()没有参数，随机取出一个元素，并将该元素从集合中去除 set.clear()清空集合 set1.difference(set2)取出集合1对集合2的差集（集合1有集合2没有的内容），返回一个集合 set1.difference_update(set2)对比集合1和集合2，在集合1内删除和集合2相同的元素。集合1被修改，集合2不变 set1.union(set2)将两个集合合并，返回一个新的集合 len(set) 6.6 dict 字典 6.6.1 字典的定义 12345# 定义字典变量名称 = {key: value, key: value, ...}#定义空字典变量名称 = {}变量名称 = dict() 6.6.2 字典的常用方法 访问时可以使用dict[key]获取某一键的值 dict.keys()返回包含所有键的列表 dict.has_key(k)检查字典中是否含有某一键 dict.values()返回包含所有值的列表 dict.get(key)返回字典的键 dict.items()返回有键值对组成的元组 dict.copy()复制字典到另一字典 del dict(key)删除指定键的元素 dict.clear()清除键的所有元素 dict.pop(key)弹出某一键的值，并从字典中删除 第七章 Python函数进阶 7.1 函数的多返回值 return函数后面可以写多个返回值，用逗号隔开 1234def test_return(): return 1, \"hello\", Truex, y, z = test_return()# x,y,z会对应接收到相应的值 7.2 函数的多种传参方式 Python的传参是传对象引用，是一个对象的内存地址，是传值和传址的一个综合 如果收到的是一个可以改变（字典或者列表）的对象的引用，就能修改对象的初始值；如果是一个不可修改（数字、字符、字符串或者元组）的对象，则不能直接修改原始对象。 7.2.1 位置参数 调用函数时根据函数定义的参数位置来传递参数 7.2.2 关键值参数 函数调用时通过“键=值”形式传递参数 123456def user_info(name, age, gender): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")# 关键字参数user_info(name='小王', age=11, gender='女')user_info(age=10, gender='女', name='潇潇') # 可以不按照参数的定义顺序传参user_info('甜甜', gender='女', age=9) # 不表明名称的位置需对应 7.2.3 缺省参数 参数提供默认值，调用函数时可不传该默认参数的值 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用 12345def user_info(name, age, gender='男'): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")user_info('小天', 13, '女')user_info('小乐', 13) 7.2.4 不定长参数 不定长参数有两种类型 1. 位置传递（元组，*号） 2. 关键字传递（字典，**号） 1234567891011# 不定长 - 位置不定长, *号# 不定长定义的形式参数会作为元组存在，接收不定长数量的参数传入def user_info(*args): print(f\"args参数的类型是：{type(args)}，内容是:{args}\")user_info(1, 2, 3, '小明', '男孩')# 不定长 - 关键字不定长, **号def user_info(**kwargs): print(f\"args参数的类型是：{type(kwargs)}，内容是:{kwargs}\")user_info(name='小王', age=11, gender='男孩') 7.3 函数可以作为参数传递 函数本身是可以作为参数，传入另一个函数中进行使用的。 将函数传入的作用在于：传入计算逻辑，而非传入数据。 1234567891011# 定义一个函数，接收另一个函数作为传入参数def test_func(compute): result = compute(1, 2) # 确定compute是函数 print(f\"compute参数的类型是:{type(compute)}\") print(f\"计算结果：{result}\")# 定义一个函数，准备作为参数传入另一个函数def compute(x, y): return x + y# 调用，并传入函数test_func(compute) 在如上的例子中，test_func函数中需要一个函数，对1和2进行某种运算，外部定义了一个compute作为参数传递给了test_func函数 7.4 lambda匿名函数 lambda关键字，可以定义匿名函数（无名称），无名称的匿名函数，只可临时使用一次。 lambda函数基本语法：lambda 传入参数：函数体（一行代码） 第八章 文件操作 8.1 打开文件 使用open函数打开文件，并返回一个文件对象 myfile = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]]) mode为文件的读写模式 | mode | 模式 | 文件不存在时 | 是否覆盖写 | | :---: | :---: | :----------: | :---------------: | | r | 只读 | 报错 | - | | r+ | 读写 | 报错 | 是 | | w | 只写 | 新建文件 | 是 | | w+ | 读写 | 新建文件 | 是 | | a | 只写 | 新建文件 | 否，从EOF处开始写 | | a+ | 读写 | 新建文件 | 否，从EOF处开始写 | 在字母后面加上b表示用二进制打开相应的文件，如rb+ 用w或a打开文件时，文件指针指向文件末尾；用r打卡文件时，文件指针指向文件开头 encoding为编码格式（推荐使用UTF-8）。encoding的位置不是第三位，如果要说明的话，应使用关键字参数。也可省略。 8.2 文件的常用属性 file.name：返回文件的名称； file.mode：返回打开文件时，采用的文件打开模式； file.encoding：返回打开文件时使用的编码格式； file.closed：判断文件是否己经关闭。 8.3 文件的常用方法 file.close() file.flush()刷新输出缓存 file.read([size])如果设置了size，则读取size字节；如果没设置，则读取问价全部内容。 file.readline([size])如果设置了size，size小于改行总字节，则读取size字节；如果大于，则读取该行的所有内容 file.readlines()读取完文件，返回每行组成的列表 file.write(str)将字符串写入文件 file.writelines(sequence of strings)写多行到文件，参数可以是字符串，也可以是列表 file.seek(n)将文件指针移动到第n字节，0表示开头 file.tell()返回文件指针当前的位置 8.4 shutil模块 shutil模块中包含一些函数，用于复制、移动、改名和删除文件 第九章 Python异常、模块与包 9.1 异常 捕获常规异常 12345678try: 可能发生错误的代码except: 如果出现异常执行的代码else: 如果异常不出现执行的代码finally: 无论异常是否出现都要执行的代码 捕获指定异常 12345try: print(name)except NameError as e: print('name变量名称未定义错误')# 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 捕获多个异常，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写 1234try: print(1/0)except (NameError, ZeroDivisionError): print('ZeroDivision错误...') 捕获所有异常，并输出 1234try: print(name)except Exception as e: print(e) 异常是具有传递性的 当我们想要保证程序不会因为异常崩溃的时候, 就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到main函数中, 这样就可以确保所有的异常都会被捕获 9.2 模块 模块是一个python文件，里面有类、函数、变量等等，可以导入模块来用 模块的导入语法： [from 模块名] import [模块|类|变量|函数| * ] [as 别名] 模块的使用： 模块名.功能名 12345678910# 使用import导入time模块中的sleep功能# 方法1import timetime.sleep(5)# 方法2from time import sleepsleep(5)# 方法3from time import *sleep(5) 注意：当导入多个模块，且模块内有重名的功能时，调用这个重名的功能时，使用的是后导入模块的该功能 if __name__ == '__main__': 可以用于某模块内部的运行代码，防止在导入模块时执行内置语句 __all__ = [' ' , ' ' , ...] 当模块文件中有 __all__ 变量，使用 from xxx import * 导入时，只能导入列表中的元素 9.3 包 包就是一个文件夹，其中包含了很多的py文件和一个_init.py文件","link":"/2022/08/30/python%E5%9F%BA%E7%A1%80/"},{"title":"密码学期末复习","text":"1. 概述 1.1 引言 1949年，香农的《保密系统通信理论》将密码学推向基于信息论的学科，近代密码学诞生。 1976年，Diffie和Hellman提出公钥密码学的思想，开启了现代密码学。 我国密码分级：核心密码（核心机密）、普通密码（高于商用）、商用密码（非机密）、个人密码（个人隐私）。前三种密码都由国家密码管理局统一管理。 1.2 网络安全概念 信息安全三要素（CIA）： 机密性 数据保密性：隐私或者秘密数据不向非授权者泄露、也不被他们使用 隐私性：个人能够控制和确定自身相关的哪些信息可以被收集、保存、公开及向谁公开 完整性 数据完整性：信息和程序只能以特定的方式进行改变 系统完整性：系统以一种正常的方式执行预定的功能，免于被非法的操控 可用性 除此之外，还需要一些安全概念： 真实性：一个实体是真实、可被验证的，或者信息和信息的来源是正确的。 可追溯性：实体的行为可以追溯到唯一的该实体。 安全泄露事件的影响： 执行使命的能力 资产损失 经济损失 对个人的伤害 低 能力一定程度降低，效果稍有降低 较少 很小 很小 中 能力显著降级，能完成主要功能，但效果明显降低 显著 显著 显著，但是不威胁生命安全 高 能力严重降级，不能完成一项或多项功能 大部分 大部分 严重，包括威胁生命安全 OSI安全框架：安全方面：攻击、机制和服务 安全攻击：任何危及信息系统安全的行为。 安全机制：用来检测、阻止攻击或从攻击状态恢复到正常状态的过程。 安全服务：利用一种或多种安全机制进行反攻击。 安全攻击 安全漏洞是信息系统产生安全问题的内因，也叫缺陷、隐患、脆弱性。 安全威胁是信息系统产生安全问题的外因，也叫攻击。 安全威胁分为： 自然威胁：各种自然灾害、设备老化等 人为威胁：对信息及信息系统的人为攻击，通过找弱点，到达破坏、欺骗等效果 攻击方式有两种：主动攻击和被动攻击。 被动攻击：窃听，不影响正常的通信，不对信息进行任何修改，以获取信息为目的。 被动攻击分为：信息内容的泄露、流量分析。 主动攻击：对数据流进行篡改，或者产生假的信息。 主动攻击包括： 拒绝服务：对系统可用性进行攻击。 消息修改：修改消息内容、延迟传输、修改消息顺序等。破坏完整性。 伪装：假装成其他实体。对真实性进行攻击。 重放：将截获的信息再次发送。 安全服务：对系统资源进行特殊保护的处理或者通信服务。 数据保密性：防止消息内容泄露，被窃听。防止被动攻击 认证：保证通信的真实性。包括单向通信和双向通信 数据完整性：保证所接受的信息是未经修改或重放的，还能用于对一定程度损坏的数据的恢复。 不可否认性：接收者能证明消息的真实来源，发送者能证实接收者已经接受了消息 访问控制：检查用户是否对某一资源有访问权。实现方式是认证 安全机制 大多数机制的共同点：密码技术 特定的安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证 普遍的安全机制：可信功能、安全标签、事件检测、安全审计追踪、安全恢复 安全服务与机制间的联系（表格） 网络安全模型：两个基本成分和一个可选成分： 消息的安全变换 通信双方共享的秘密信息 有时需要一个可信第三方 3. 传统加密技术 3.1 密码学发展史 三个阶段： -1949：古典密码 1949-1975：计算机使得基于复杂计算的密码成为可能。数据的安全性基于密钥而不是算法的保密。 1976-：公钥密码、对称密码进一步发展 3.2 对称密码模型 密钥为，密钥可能值的范围为密钥空间。加解密函数为： 对于加解密过程，明文加密后再解密得到的内容必须和原来明文相同。 密码学：研究信息的保密和复原保密信息以获取其真实内容的学科称为密码学。它包括密码编码学和密码分析学。 密码编码学：研究对信息进行编码实现隐蔽信息的一门学科。 密码分析学：不知道任何加密细节的条件下解密消息的技术，即“破译”。 对称密码： 又称传统密码、常规密码、私钥密码、单钥密码 发送方和接收方共享一个共同的密钥。 对称密码安全的两个必备条件： 加密算法必须足够强 发送者和接收者在某种安全的形式下获得密钥并且保证密钥的安全 Kerckhoff原则：系统的保密性不依赖于对加密体制或算法的保密，而依赖于对密钥的保密。 密码编码学的三个特征： 明文转换为密文的运算类型：代替（元素映射到另一个元素）、置换（元素的重新排列）。要求运算是可逆的。 所用的密钥数：单钥密码（基于计算安全性，即破译的计算量下限）、双钥密码（基于可证明安全性，即依赖数学难题） 处理明文的方法：分组密码、序列密码（流密码） 密码分析学： 目标：得到密钥 攻击方法：密码分析（利用算法的性质、明文的特性、明密文对）、穷举攻击 基于密码分析的攻击： 唯密文攻击 已知明文攻击：已知多个明文-密文对 选择明文攻击：由破译者选择的明文信息及其密文 选择密文攻击：由破译者选择的密文信息及其明文 选择文本攻击：选择明文+密文攻击 无条件安全：算法产生的密文不能给出唯一决定明文的足够信息，此时敌手获得多少密文用多长时间都不能解密密文。仅当密钥至少和明文一样长时，才能达到无条件安全。即只有一次一密方案是无条件安全的。 计算上安全：破译密文的代价超过被加密信息的价值或破译密文所花的时间超过信息的有用期。计算上安全弱于无条件安全。 穷举攻击：敌手想找出一个私钥，采用穷举攻击。若k是均匀随机分布的，则敌手需要平均尝试： 3.3 代替技术 凯撒密码","link":"/2023/06/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"大二下","slug":"大二下","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"大二上","slug":"大二上","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8A/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"categories":[]}