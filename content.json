{"pages":[{"title":"","text":"I'm Harrison-1eo An undergraduate student at the School of Cyberspace Security of Beihang University If you have any questions, welcome to contact me via email. 😊😊😊😁😁😁😋😋😋 😎😎😎🤗🤗🤗🤩🤩🤩 😝😝😝🫣🫣🫣🥺🥺🥺","link":"/about/index.html"},{"title":"","text":"Harrison-1eo (Harrison) (github.com)","link":"/links/index.html"}],"posts":[{"title":"python 基础语法","text":"第一章 python简介 第二章 python基础语法 2.1 简单输出 12print(666)print([输出项1,输出项2,...] [,sep=分隔符] [,end=结束符]) 默认分隔符为空格，结束符为换行符 2.2 注释 使用 # 表示单行注释 使用 \"\"\" 表示多行注释 2.3 变量 变量是没有类型的，但是变量存储的数据是有类型的 可以使用 type() 查看变量类型 123456money = 50print(\"我还有\", money, \"块钱\")print(type(money))type_int = type(money)print(type_int)print(type(type_int)) 输出结果为 1234我还有 50 块钱&lt;class 'int'&gt;&lt;class 'int'&gt;&lt;class 'type'&gt; 2.4 数据类型显式转换 可以使用 int(x) float(x) str(x) 转换成相应的数据类型 注意 任何类型都可以转换成字符串类型，但是转换为int和float类型之前需要确保能转换到相应的类型 2.5 运算符 常用运算符 + - * / % // 两个斜杠为取整除,即只保留结果的整数部分 ** 两个星号为幂运算 1234print(9//2)print(9.0//2.0)print(3**2)# 输出结果为4 4.0 9 not：取反运算符 and：与运算符 or 或运算符 成员运算符 - in：在指定序列中找到指定的值则返回True，否则返回False - not in 身份运算符 - is：判断两个标识符是否引用了同一个对象 - not is 2.6 字符串 字符串定义法：单引号，双引号，三引号（可以换行） 字符串内部可以使用转义字符 \\ 来输出引号 可以使用加号（+）来对字符串进行拼接，但是不用拼接其他类型的变量,需要转换成字符串类型 ### 字符串格式化表示法 形式类似于c语言中printf括号中的内容 123massage = \"第%d个苹果重%.2f%s\" % (3, 1.2, \"kg\")print(massage)# 输出结果：第3个苹果重1.20kg 此处类似于%5.4f格式的效果与C语言相同 注意，在本格式化表示方法中，小数会自动在后面添加若干个0 字符串快速格式化 f\"内容{变量}\"的格式来快速格式化 123money = 1.2massage = f\"我有{money}这么多钱\"# 输出结果：我有1.2这么多钱 此种方法不需要进行精度处理，数字内容不变，小数位数也不变 2.7 input语句 使用 input() 语句可以从键盘获取输入 使用一个变量接收（存储）input语句获取的键盘输入数据即可 无论输入的数据是什么，都是存储为string类型的 第三章 Python判断语句 3.1 布尔类型和比较运算符 bool类型表示真和假 True 为真，为 1 False 为假，为 0 比较运算符与C语言相同，注意，==表示判断是否相等 3.2 if语句 语法格式： 123456789if 条件： 语句1elif 条件2： 语句2elif 条件3： 语句3...else： 语句N 注意，一定要进行缩进，python通过缩进的对齐判断语句的归属 条件判断语句的结果一定是bool类型的结果 第四章 Python循环语句 4.1 while循环 语法格式： 1234while 条件： 语句1 语句2 ... ## 4.2 for循环 - while循环的循环条件是自定义的，自行控制循环条件 - for循环是一种”轮询”机制，是对一批内容进行”逐个处理”将数据集中的每一个内容取出来进行处理。for循环是无法定义循环条件的，只能从数据集中依次取出内容 语法格式： 12for 临时变量 in 待处理数据集: 循环满足条件时执行的代码 例如： 12345name = \"itheima\"# for循环处理字符串for x in name: print(x)# 运行结果为将字符串中字符一个一个拿出来输出 语法格式中\"待处理数据集\"实际上为一个序列类型，其中包括字符串，列表，元组等等 通过range语句可以获得一个简单的数字序列，用于for循环中 range(num) 为从0到num的数字序列(不包含num本身) range(num1,num2) 为从num1到num2的数字序列(不包含num2本身) range(num1,num2,step) 为从num1到num2的数字序列(不包含num2本身)，步长为step 临时变量在编程规范上，作用范围（作用域）只限定在for循环内部 如果在for循环外部访问临时变量： 实际上是可以访问到的。但是在编程规范上，是不允许、不建议这么做的 4.3 continue和break 在嵌套循环中，只能作用在所在的循环上，无法对上层循环起作用 4.4 pass pass是空语句，不执行任何操作，一般用作占位语句，保持程序的完整性 第五章 Python函数基础 5.1 函数的基本定义 123def 函数名(传入参数)： 函数体 return 返回值 应先定义函数，后调用函数 参数不需要，可以省略 返回值不需要，可以省略 可以在def一行下面采用多行注释的方式写该函数的说明文档 5.2 None类型 Python中有一个特殊的字面量：None，其类型是：&lt;class 'NoneType'&gt; 无返回值的函数，实际上就是返回了：None这个字面量 None表示：空的、无实际意义的意思 return None，效果等同于不写return语句 在if判断中，None等同于False 一般用于在函数中主动返回None，配合if判断做相关处理 用于声明无内容的变量上 定义变量，但暂时不需要变量有具体值，可以用None来代替，例如name = None 5.3 局部变量与全局变量 在某一函数体内的为局部变量，只能在该函数体内生效 使用 global 关键字可以在函数内部声明全局变量 第六章 Python数据容器 6.1 list 列表 列表的特点： - 可以容纳多个元素（上限为2**63-1个） - 可以容纳不同类型的元素（混装） - 数据是有序存储的（有下标序号） - 允许重复数据存在 - 可以修改（增加或删除元素等） 6.1.1 列表的定义 12345# 定义变量变量名称 = [元素1, 元素2, ...]#定义空列表变量名称 = []变量名称 = list() 以 [] 作为表示，列表内每个元素之间以 , 隔开 列表可以一次存储多个数据，并且可以是不同的数据类型，支持嵌套 6.1.2 列表的下标索引 从头开始第一个的索引为0，一直到最后，如 list[2] 从尾开始最后一个的索引是-1，一直到最前 如果是列表嵌套列表，则可以使用类似C语言二位数组的表达方式，如 list[1][2] 要注意下标索引的取值范围，超出范围无法取出元素，并且会报错 6.1.3 列表的常用方法 在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法 方法的使用格式为 对象.方法(传入参数) 方法 作用 列表.index(元素) 查找指定元素在列表的下标找不到报错ValueError 列表[下标] = 值 修改特定位置的值 列表.insert(下标, 元素) 在指定的下标位置，插入指定的元素 列表.append(元素) 将指定元素，追加到列表的尾部 列表.extend(其它数据容器) 将其它数据容器的内容取出，依次追加到列表尾部 del 列表[下标] 删除列表指定下标元素 列表.pop(下标) 删除列表指定下标元素 列表.remove(元素) 从前向后，删除此元素第一个匹配项 列表.clear() 清空列表 列表.count(元素) 统计此元素在列表中出现的次数找不到报错ValueError len(列表) 统计容器内有多少元素 6.2 tuple 元组 元组的特点： - 有序、任意数量元素、允许重复元素 - 不可修改 元组内容不可以直接修改，会报错 如果元组内部有列表元素，列表中的内容可以修改 6.2.1 列表的定义 12345# 定义元组变量名称 = (元素1, 元素2, ...)#定义空元组变量名称 = ()变量名称 = tuple() 如果定义的元组只有一个元素时，在元素1后面要加一个逗号，例如 (1,)，不然则不是元组类型 6.2.2 元组的下标索引 写法与列表相同，索引从0开始计算 6.2.3 元组的常用方法 元组.index() 元组.count() len(元组) 实际效果见6.1.3表格 6.3 str 字符串 字符串的特点： - 只可以储存字符串，长度任意 - 不可修改，如果要修改，只能得到一个新的字符串 6.3.1 字符串的下标索引 类似于C语言中字符数组，可以通过下标索引取出字符，索引从0号开始计算，但是没有最后的‘\\0’占位符 6.3.2 字符串的常用方法 str.index(参数)参数可以是一个字符，也可以是一个字符串 str.replace(m,n)将字符串中的m字符串替换为n字符串，返回一个新的字符串 str.split(分隔符)按照指定的分割符将字符串分为多个字符串，返回一个列表对象 str.strip(参数)去除字符串前后的参数中的内容，注意是按照字符去除，而不是整体的字符串匹配。如果不传入参数则默认去除字符串前后的空格和换行 str.count(参数) len(str) 6.4 序列的切片 序列是指能用下标索引的容器，例如：列表、元组、字符串 切片：从一个序列中取出一个子序列 语法：序列[起始下标：结束下标：步长]，返回一个新的序列 结束下标表示到某位结束，不包含结束位 起始下标留空表示从头开始，结束下标留空表示截取到结尾 步长可以为正数，也可以为负数，表示反向取，主要这时起始下标和结束下标也要反向标记 str[::-1]相当于将字符串从尾到头倒序输出 6.5 set 集合 集合的特点： - 无序，不支持下标索引访问 - 可以修改 - 数据不能重复 - 可以容纳多个数据，不同的数据类型 6.5.1 集合的定义 1234# 定义集合变量名称 = {元素1, 元素2, ...}#定义空集合变量名称 = set() 6.5.2 集合的常用方法 set.add(ele) set.remove(ele) set.pop()没有参数，随机取出一个元素，并将该元素从集合中去除 set.clear()清空集合 set1.difference(set2)取出集合1对集合2的差集（集合1有集合2没有的内容），返回一个集合 set1.difference_update(set2)对比集合1和集合2，在集合1内删除和集合2相同的元素。集合1被修改，集合2不变 set1.union(set2)将两个集合合并，返回一个新的集合 len(set) 6.6 dict 字典 6.6.1 字典的定义 12345# 定义字典变量名称 = {key: value, key: value, ...}#定义空字典变量名称 = {}变量名称 = dict() 6.6.2 字典的常用方法 访问时可以使用dict[key]获取某一键的值 dict.keys()返回包含所有键的列表 dict.has_key(k)检查字典中是否含有某一键 dict.values()返回包含所有值的列表 dict.get(key)返回字典的键 dict.items()返回有键值对组成的元组 dict.copy()复制字典到另一字典 del dict(key)删除指定键的元素 dict.clear()清除键的所有元素 dict.pop(key)弹出某一键的值，并从字典中删除 第七章 Python函数进阶 7.1 函数的多返回值 return函数后面可以写多个返回值，用逗号隔开 1234def test_return(): return 1, \"hello\", Truex, y, z = test_return()# x,y,z会对应接收到相应的值 7.2 函数的多种传参方式 Python的传参是传对象引用，是一个对象的内存地址，是传值和传址的一个综合 如果收到的是一个可以改变（字典或者列表）的对象的引用，就能修改对象的初始值；如果是一个不可修改（数字、字符、字符串或者元组）的对象，则不能直接修改原始对象。 7.2.1 位置参数 调用函数时根据函数定义的参数位置来传递参数 7.2.2 关键值参数 函数调用时通过“键=值”形式传递参数 123456def user_info(name, age, gender): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")# 关键字参数user_info(name='小王', age=11, gender='女')user_info(age=10, gender='女', name='潇潇') # 可以不按照参数的定义顺序传参user_info('甜甜', gender='女', age=9) # 不表明名称的位置需对应 7.2.3 缺省参数 参数提供默认值，调用函数时可不传该默认参数的值 注意：所有位置参数必须出现在默认参数前，包括函数定义和调用 12345def user_info(name, age, gender='男'): print(f\"姓名是:{name}, 年龄是:{age}, 性别是:{gender}\")user_info('小天', 13, '女')user_info('小乐', 13) 7.2.4 不定长参数 不定长参数有两种类型 1. 位置传递（元组，*号） 2. 关键字传递（字典，**号） 1234567891011# 不定长 - 位置不定长, *号# 不定长定义的形式参数会作为元组存在，接收不定长数量的参数传入def user_info(*args): print(f\"args参数的类型是：{type(args)}，内容是:{args}\")user_info(1, 2, 3, '小明', '男孩')# 不定长 - 关键字不定长, **号def user_info(**kwargs): print(f\"args参数的类型是：{type(kwargs)}，内容是:{kwargs}\")user_info(name='小王', age=11, gender='男孩') 7.3 函数可以作为参数传递 函数本身是可以作为参数，传入另一个函数中进行使用的。 将函数传入的作用在于：传入计算逻辑，而非传入数据。 1234567891011# 定义一个函数，接收另一个函数作为传入参数def test_func(compute): result = compute(1, 2) # 确定compute是函数 print(f\"compute参数的类型是:{type(compute)}\") print(f\"计算结果：{result}\")# 定义一个函数，准备作为参数传入另一个函数def compute(x, y): return x + y# 调用，并传入函数test_func(compute) 在如上的例子中，test_func函数中需要一个函数，对1和2进行某种运算，外部定义了一个compute作为参数传递给了test_func函数 7.4 lambda匿名函数 lambda关键字，可以定义匿名函数（无名称），无名称的匿名函数，只可临时使用一次。 lambda函数基本语法：lambda 传入参数：函数体（一行代码） 第八章 文件操作 8.1 打开文件 使用open函数打开文件，并返回一个文件对象 myfile = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]]) mode为文件的读写模式 | mode | 模式 | 文件不存在时 | 是否覆盖写 | | :---: | :---: | :----------: | :---------------: | | r | 只读 | 报错 | - | | r+ | 读写 | 报错 | 是 | | w | 只写 | 新建文件 | 是 | | w+ | 读写 | 新建文件 | 是 | | a | 只写 | 新建文件 | 否，从EOF处开始写 | | a+ | 读写 | 新建文件 | 否，从EOF处开始写 | 在字母后面加上b表示用二进制打开相应的文件，如rb+ 用w或a打开文件时，文件指针指向文件末尾；用r打卡文件时，文件指针指向文件开头 encoding为编码格式（推荐使用UTF-8）。encoding的位置不是第三位，如果要说明的话，应使用关键字参数。也可省略。 8.2 文件的常用属性 file.name：返回文件的名称； file.mode：返回打开文件时，采用的文件打开模式； file.encoding：返回打开文件时使用的编码格式； file.closed：判断文件是否己经关闭。 8.3 文件的常用方法 file.close() file.flush()刷新输出缓存 file.read([size])如果设置了size，则读取size字节；如果没设置，则读取问价全部内容。 file.readline([size])如果设置了size，size小于改行总字节，则读取size字节；如果大于，则读取该行的所有内容 file.readlines()读取完文件，返回每行组成的列表 file.write(str)将字符串写入文件 file.writelines(sequence of strings)写多行到文件，参数可以是字符串，也可以是列表 file.seek(n)将文件指针移动到第n字节，0表示开头 file.tell()返回文件指针当前的位置 8.4 shutil模块 shutil模块中包含一些函数，用于复制、移动、改名和删除文件 第九章 Python异常、模块与包 9.1 异常 捕获常规异常 12345678try: 可能发生错误的代码except: 如果出现异常执行的代码else: 如果异常不出现执行的代码finally: 无论异常是否出现都要执行的代码 捕获指定异常 12345try: print(name)except NameError as e: print('name变量名称未定义错误')# 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 捕获多个异常，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写 1234try: print(1/0)except (NameError, ZeroDivisionError): print('ZeroDivision错误...') 捕获所有异常，并输出 1234try: print(name)except Exception as e: print(e) 异常是具有传递性的 当我们想要保证程序不会因为异常崩溃的时候, 就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到main函数中, 这样就可以确保所有的异常都会被捕获 9.2 模块 模块是一个python文件，里面有类、函数、变量等等，可以导入模块来用 模块的导入语法： [from 模块名] import [模块|类|变量|函数| * ] [as 别名] 模块的使用： 模块名.功能名 12345678910# 使用import导入time模块中的sleep功能# 方法1import timetime.sleep(5)# 方法2from time import sleepsleep(5)# 方法3from time import *sleep(5) 注意：当导入多个模块，且模块内有重名的功能时，调用这个重名的功能时，使用的是后导入模块的该功能 if __name__ == '__main__': 可以用于某模块内部的运行代码，防止在导入模块时执行内置语句 __all__ = [' ' , ' ' , ...] 当模块文件中有 __all__ 变量，使用 from xxx import * 导入时，只能导入列表中的元素 9.3 包 包就是一个文件夹，其中包含了很多的py文件和一个_init.py文件","link":"/2022/08/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"密码学期末复习（PPT）","text":"1. 概述 1.1 引言 1949年，香农的《保密系统通信理论》将密码学推向基于信息论的学科，近代密码学诞生。 1976年，Diffie和Hellman提出公钥密码学的思想，开启了现代密码学。 我国密码分级：核心密码（核心机密）、普通密码（高于商用）、商用密码（非机密）、个人密码（个人隐私）。前三种密码都由国家密码管理局统一管理。 1.2 网络安全概念 信息安全三要素（CIA）： 机密性 数据保密性：隐私或者秘密数据不向非授权者泄露、也不被他们使用 隐私性：个人能够控制和确定自身相关的哪些信息可以被收集、保存、公开及向谁公开 完整性 数据完整性：信息和程序只能以特定的方式进行改变 系统完整性：系统以一种正常的方式执行预定的功能，免于被非法的操控 可用性 除此之外，还需要一些安全概念： 真实性：一个实体是真实、可被验证的，或者信息和信息的来源是正确的。 可追溯性：实体的行为可以追溯到唯一的该实体。 安全泄露事件的影响： 执行使命的能力 资产损失 经济损失 对个人的伤害 低 能力一定程度降低，效果稍有降低 较少 很小 很小 中 能力显著降级，能完成主要功能，但效果明显降低 显著 显著 显著，但是不威胁生命安全 高 能力严重降级，不能完成一项或多项功能 大部分 大部分 严重，包括威胁生命安全 OSI安全框架：安全方面：攻击、机制和服务 安全攻击：任何危及信息系统安全的行为。 安全机制：用来检测、阻止攻击或从攻击状态恢复到正常状态的过程。 安全服务：利用一种或多种安全机制进行反攻击。 安全攻击 安全漏洞是信息系统产生安全问题的内因，也叫缺陷、隐患、脆弱性。 安全威胁是信息系统产生安全问题的外因，也叫攻击。 安全威胁分为： 自然威胁：各种自然灾害、设备老化等 人为威胁：对信息及信息系统的人为攻击，通过找弱点，到达破坏、欺骗等效果 攻击方式有两种：主动攻击和被动攻击。 被动攻击：窃听，不影响正常的通信，不对信息进行任何修改，以获取信息为目的。 被动攻击分为：信息内容的泄露、流量分析。 主动攻击：对数据流进行篡改，或者产生假的信息。 主动攻击包括： 拒绝服务：对系统可用性进行攻击。 消息修改：修改消息内容、延迟传输、修改消息顺序等。破坏完整性。 伪装：假装成其他实体。对真实性进行攻击。 重放：将截获的信息再次发送。 安全服务：对系统资源进行特殊保护的处理或者通信服务。 数据保密性：防止消息内容泄露，被窃听。防止被动攻击 认证：保证通信的真实性。包括单向通信和双向通信 数据完整性：保证所接受的信息是未经修改或重放的，还能用于对一定程度损坏的数据的恢复。 不可否认性：接收者能证明消息的真实来源，发送者能证实接收者已经接受了消息 访问控制：检查用户是否对某一资源有访问权。实现方式是认证 安全机制 大多数机制的共同点：密码技术 特定的安全机制：加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证 普遍的安全机制：可信功能、安全标签、事件检测、安全审计追踪、安全恢复 安全服务与机制间的联系（表格） 网络安全模型：两个基本成分和一个可选成分： 消息的安全变换 通信双方共享的秘密信息 有时需要一个可信第三方 3. 传统加密技术 3.1 密码学发展史 三个阶段： -1949：古典密码 1949-1975：计算机使得基于复杂计算的密码成为可能。数据的安全性基于密钥而不是算法的保密。 1976-：公钥密码、对称密码进一步发展 3.2 对称密码模型 密钥为，密钥可能值的范围为密钥空间。加解密函数为： 对于加解密过程，明文加密后再解密得到的内容必须和原来明文相同。 密码学：研究信息的保密和复原保密信息以获取其真实内容的学科称为密码学。它包括密码编码学和密码分析学。 密码编码学：研究对信息进行编码实现隐蔽信息的一门学科。 密码分析学：不知道任何加密细节的条件下解密消息的技术，即“破译”。 对称密码： 又称传统密码、常规密码、私钥密码、单钥密码 发送方和接收方共享一个共同的密钥。 对称密码安全的两个必备条件： 加密算法必须足够强 发送者和接收者在某种安全的形式下获得密钥并且保证密钥的安全 Kerckhoff原则：系统的保密性不依赖于对加密体制或算法的保密，而依赖于对密钥的保密。 密码编码学的三个特征： 明文转换为密文的运算类型：代替（元素映射到另一个元素）、置换（元素的重新排列）。要求运算是可逆的。 所用的密钥数：单钥密码（基于计算安全性，即破译的计算量下限）、双钥密码（基于可证明安全性，即依赖数学难题） 处理明文的方法：分组密码、序列密码（流密码） 密码分析学： 目标：得到密钥 攻击方法：密码分析（利用算法的性质、明文的特性、明密文对）、穷举攻击 基于密码分析的攻击： 唯密文攻击 已知明文攻击：已知多个明文-密文对 选择明文攻击：由破译者选择的明文信息及其密文 选择密文攻击：由破译者选择的密文信息及其明文 选择文本攻击：选择明文+密文攻击 无条件安全：算法产生的密文不能给出唯一决定明文的足够信息，此时敌手获得多少密文用多长时间都不能解密密文。仅当密钥至少和明文一样长时，才能达到无条件安全。即只有一次一密方案是无条件安全的。 计算上安全：破译密文的代价超过被加密信息的价值或破译密文所花的时间超过信息的有用期。计算上安全弱于无条件安全。 穷举攻击：敌手想找出一个私钥，采用穷举攻击。若k是均匀随机分布的，则敌手需要平均尝试： 3.3 代替技术 凯撒密码 字母表位移k位 共有26种可能的密钥，25种有效 加密： 解密： 采样密码（乘法密码） 明文字母表每隔k位取出一个 要求密钥k与26互素，有 个 可用密钥 加密： 解密： 仿射代替密码 加法和乘法结合 q=26时，共26*12-1 = 311 个可用密码（减去的是不变的变换） 加密： 解密： 单表代替密码： 随机映射 密钥数目： 缺陷：密文字母带有明文的统计特性，明文中一个元素仅影响密文中一个元素 语言的统计特性： 单字母：极大概率：e，大概率字母：tao，较大概率：inshr 多字母 单词特性 单表代替密码之所以容易被攻击，是因为每个密文字母都是用同一个代替密表加密而成的，相同的密文字母对应着相同的明文字母。实际上只是改变字母的名称。 Playfair密码 多字母代替密码，5*5矩阵，先填充单词，再填充剩下的。I=J 加密：明文两个字母一组，如果两个字母相同则在中间插入一个填充字母。同行：循环向右，同列：循环向下，对角线：另一对角线，按加密两字母的行排序 优点：安全性优于单表代替密码，使用频率分析困难 Hill密码 多字母代替密码，利用矩阵 加密： 解密： 优点：完全隐藏了单字母的频率特性，可以抵抗唯密文攻击 容易被已知明文攻击破解 3.4 多表代替技术 多表代替：对每位明文采用不同的单表代替。当明文和密钥一样长时成为一次一密密码。 维吉尼亚密码：明文，密钥，密文 26*26表格，行和列均为a-z，表内为每行以a.b.c...z开头的凯撒密码 加密： 解密： 博福特密码： 加密： 解密： 弗纳姆Vernam密码： 与密钥诸位异或 一次一密： 在Vernam密码中，如果采用的密钥不重复就是一次一密体制 在理论上不可被破解，但是在实际上不可行 多表代替密码的破译： 对于周期多表代替密码，可以转换成多组单表代替密码进行破译。 3.5 其他技术 置换技术 轮转机 隐写术 4. 分组密码和数据加密标准 4.1 Feistel密码 分组密码：明文分组加密，得到等长的密文分组。解密算法是加密算法的逆运算。 可逆变换：每个明文分组唯一对应一个密文分组。映射的总数是 。称为理想分组密码。 混淆：是密文和加密密钥之间关系变得复杂，以阻止攻击者发现密钥。 扩散：每个密文字母尽可能受多个明文数字的影响，使得明文的统计特性消散在密文中。 乘积密码：在单个加密机制中依次使用两个或两个以上不同类型的基本密码，所得结果的密码强度将强于每个单个密码的强度。 Feistel密码是一种特殊的SP网络，交替使用代替和置换，增强密码的扩散和混淆性能。 Feistel密码的结构：加密和解密完全相同 在Feistal密码结构中，中间经过若干轮上述基本结构，加密和解密的最后都要添加一步交换L和R F函数不必可逆。 Feistel密码的解密过程与加密过程实质相同，无需区分实现加密和解密算法，只是密钥使用顺序不同。 Feistel密码的设计： 分组越大，安全性越高，但是计算越慢 密钥越长，安全性越高，但是计算越慢 循环越多，安全性越高 子密钥产生算法和轮函数设计越复杂，安全性越高 DES、SM4为分组密码 3.2 数据加密标准(DES) DES（Data Encryption Standard）使用56比特的密钥加密64位的明文，得到64位的密文。 算法的实现过程： 初始置换IP： 16轮迭代运算：，子密钥长48位 迭代运算过程包含4步： --32bit--&gt; 扩展置换E --48bit--&gt; 与子密钥异或 --48bit--&gt; S盒代替 --32bit--&gt; 置换运算P --32bit--&gt; 逆置换IP-1： S盒：唯一的非线性变换，决定了算法的安全强度，起到混淆的作用。DES中的S盒接受6bit，第一位和最后一位组成选择行，中间4位选择列，输出4比特 子密钥的产生： 密钥扩展算法要求子密钥的统计独立性和灵敏性，从一些子密钥中获得其他子密钥在计算上是困难的。 雪崩效应：明文或密钥的一点小的变动都引起密文的较大变化。P置换的目的是提供雪崩效应。 弱密钥：初始密钥产生的16个子密钥相同。 半弱密钥：存在不相等的，使得。DES一共有6对半弱密钥。 差分密码攻击：通过比较两个已知明文差异的明密文对，在使用相同子密钥的情况下搜索密文中的已知差异。 线性密码分析：基于找到DES中进行变换的线性近似，可以在有2^47个已知明文的情况下破译DES密钥，但实践中仍不可行。 分组密码的整体结构：Feistel结构和SP网络 SP网络结构：每一轮中，轮输入首先被一个由子密钥控制的可逆函数S（混淆）作用，然后再对所得结果用置换（或可逆线性变换）P（扩散）作用。SP网络结构可以更快的扩散，但加解密通常不相似。 3.3 多重加密与三重DES算法 闭合的加密算法：对于任意密钥，都存在，使得： 对于闭合的加密算法，多次加密并不能增强安全性。但是DES不是一个闭合的加密算法，所以二重DES和三重DES有一定的价值。 二重DES的强度不等于56*2=112bit密钥的密码强度，会受到中途相遇攻击： 中途相遇攻击： 加密： 已知一对。对所有可能的种对进行加密，得到z，存储为一个字典。对所有可能的种对进行解密，得到z，此时可以查找上述字典，配对x和y，一旦找到则确定两个密钥。 两重DES的密文有种，密钥有种，因此有种密钥能产生给定的密文。 攻击法最大的实验次数是次，即算法难度为。 如果再用一对进行对密钥的验证，则错误率降为。 三重DES： 加密： 解密： 3.4 DES的差分密码分析 通过分析特定明文差分对相对应密文差分影响来获得尽可能大的密钥。 6. 高级加密标准 6.1 代换-置换网络(SPN) 乘积密码体制：先用一种密码进行加密，对加密结果使用另一种方法进行加密。如果第二种加密方式是自己，则为二重成绩，记为。n重成绩记为。 如果，则称密码是幂等的。幂等密码体制和自己做乘积，不能提高算法安全性。古典密码大部分都是幂等的。 迭代密码：如果密码不是幂等的，则多次迭代有可能提高安全性。一种构造简单的非幂等密码体制的方法是对两个不同的密码体制做乘积，并且保证两个密码体制是不能交换的。 在代换(S)-置换(P)网络中：加密：，解密： 对于任意的线性变换，都有： 6.2 高级加密标准(AES) Rijndael是一个迭代型分组密码，其分组长度和密钥长度都可变，可以为128比特、192比特、256比特。Rijndael使用非线性结构的S-boxes，能抵抗所有已知的攻击。Rijndael中轮函数由3层不同的可逆均匀变换组成，分别为线性混合层、非线性层、密钥加层。 在第一轮之前使用一个初始密钥加层，目的是：使加解密相似、对安全性无意义、有利于差分分析。 AES是一个迭代型分组密码，其分组长度固定为128 比特，密钥长度则可以是128，192或256比特 AES流程： 128、192、256比特分别为：16、24、32字节，4、6、8字（），迭代轮数分别为10、12、14（） 分组是以字节为单位的4*4方阵.按列排序： 1234a0 a4 a8 a12a1 a5 a9 a13a2 a6 a10 a14a3 a7 a11 a15 字节代替：S盒，非线性变换，输入8位，高4位为行值，低四位为列值，输出8位 行移位：第0行不动，第1.2.3行循环左移1.2.3位。经过行移位后，1列中4个元素被分布到不同的列中。 列混淆：矩阵乘法，运算范围是：。 列混淆的逆变换： 列变换也可以通过多项式计算来定义：把状态矩阵的列视为多项式， 其中要求与模数多项式互素，这样才存在逆多项式进行逆运算。 列混淆的原理：矩阵系数是码字间最大距离的编码（MDS码），这使得有良好的混淆性。经过几轮的列混淆和行移位后，所有的输出位与所有的输入位都有关。 密钥轮加：与密钥进行逐比特异或。 密钥扩展：共生成字，前4字用于和明文异或，后面每4字用于每轮的密钥轮加中。 扩展过程中，如果下标不是4的倍数，则；如果是4的倍数，则将向左循环移动一个字节，并进行字节代换，与轮常数Rcon异或。 使用轮常数消除对称性；密码密钥的差异扩散到轮密钥中的能力，即密钥的每个位能影响到轮密钥的许多位；已知部分密码密钥或部分轮密钥比特, 不能计算出许多其它轮密钥比特；足够的非线性性, 防止只从密码密钥的差分就能完全决定所有的轮密钥差分。 AES的加密和解密的轮结构顺序不同，但是逆向行移位与逆向字节代替、轮密钥加和逆向列混淆可以交换。 行移位改变顺序，字节代替改变内容，互不影响；可以将轮密钥做逆向列变换后，则可以先逆向列混淆，在与变换后的轮密钥异或。 AES的安全性：可以抵抗差分攻击和线性密码攻击，目前还不存在快于穷举攻击的攻击方式。 评价：运算均在2^8有限域上，除了查表操作外均为简单的异或和移位操作。每一轮密钥扩展中都有非线性变换，增强了密码的抗攻击能力。 7. 分组加密的工作模式 7.1 电话本模式 ECB 明文分组，每组都使用相同的密钥加密。同一明文组总产生同样的密文组。 如果最后一组不足64位，则需要填充。 适合短消息加密，应用长消息时容易受到攻击。 7.2 密文分组链接模式 CBC 加密算法的输入是当前明文分组和前一次密文分组的异或，每个密文块依赖于前面的所有明文块。 需要使用初始化向量，IV应像密钥一样被保护。需要填充。 加密时无法并行处理。解密时，从两个邻接的密文块即可得到一个明文块，因此解密过程可以被并行化。 如果传输时发生错误，则恢复的明文中只有这个块和下一块的内容发生改变。 解密时，密文中1位的变化只会改变这个块和下一块的内容改变。 加密过程为： 7.3 密文反馈模式 CFB 利用CFB（cipher feedback）模式或OFB模式可将分组对称密码转换为流密码。 不需要对消息填充，而且运行是实时的。 需要初始向量。 加密过程不能并行化，解密过程可以。 对信道错误较敏感，错误传播：1个比特密文传输错误会传播约64/j个分组。 加密过程： 、 7.4 输出反馈模式 OFB 与CFB的区别是加密算法的输出反馈到下一轮。 优点：传输过程中的比特错误不会被传播；缺点：比CFB模式更易受到对消息流的篡改攻击。 加密过程： 7.5 计数器模式 CTR CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证不产生长时间重复输出的函数，使用一个普通的计数器是最简单和最常见的做法。 不需要填充 可并行加密，可预处理（明文不参与密钥生成），加密数据块随机访问（只需要加计数器） 加密过程： 8. 伪随机数的产生和流密码 8.1 伪随机数的产生原则 随机数序列需要满足两个特征：随机性和不可预测性 随机性： 分布均匀性：0和1均匀分布 独立性：任何子序列不能由其他子序列推导出 序列是否满足分布均匀性可以检测得出，但是是否满足独立性无法检测。有一些算法可以检测出不满足独立性。 不可预测性： 序列以后的数是不可预测的。 真随机数列是不可预测的，因为各个位之间互相独立。 伪随机数序列要注意不可预测性。 真随机数：物理噪声、高质量随机数编辑成书、真随机数发生器（TRNG） 伪随机数：使用算法生成随机数，由伪随机数发生器（PRNGs）产生 伪随机数发生器（PRNG）：生产不限长度的位流，通常作为对称流密码的输入。 伪随机函数（PRF）：用于产生固定长度的伪随机数串。如对称加密的时变值。PRF的输出常为种子加一些上下文相关的特定值。 对PRNG的要求： 通用要求：输出保密性：不知道种子的敌手不能知道伪随机串。 特定要求：随机性、不可预测性、种子的特性 随机性：尽管生成的位流是确定的，但是要显示是随机的。 不可预测性：前向不可预测性、后向不可预测性 种子的特性：安全、不可预测 PRNG的设计 特意设计的PRNG算法 基于现存密码的算法，如对称分组密码、非对称密码、Hash函数等 8.2 伪随机数发生器 8.2.1 线性同余发生器 参数：m模，a乘数，c增量，X0初始值或种子 迭代算法： 评价线性同余发生器的性能： 迭代函数应该是全周期的，级重复0 - m-1之间的所有书 产生的序列应该看上去是随机的 能有效地利用32位运算器方便的实现 在计算机中，为了满足上述指标并便于运算，m一般取，c=0，a是m的一个本原根（如7^5） 线性同余算法只在初值X0的选取具有随机性，算法本身无随机性，以后的数被确定性的产生了。 如果敌手知道算法的参数，只要知道当前的一个数，就知道了后续的所有数。 敌手知道数列中的极少一部分，就可以确定出算法的参数。 可以利用内部系统时钟修正随机数数列：产生几个数后用时钟值作为种子；或者将当前时钟值加到每个随机数上。 8.2.2 BBS发生器 参数：两个大素数，，一个随机数s与n互素 算法： 1234X[0] = s ** 2 % nfor i in range(length): X[i] = X[i-1] ** 2 % n B[i] = X[i] % 2 BBS的安全性基于大整数分解的困难性，是密码安全伪随机数比特产生器 密码安全伪随机数比特产生器：以伪随机比特产生器的输出序列的前k个比特作为输入，不存在多项式时间算法，能以大于1/2的概率预测第k+1个比特。 8.3 使用分组密码的伪随机数发生器 使用分组密码CTR模式和OFB模式： ANSI X9.17：使用3个三重DES加密，输出一个64比特的伪随机数和一个64比特的新种子 8.4 流密码 伪随机数发生器的输出称为密钥流，密钥流和明文流的每一个字节进行按位异或运算，得到一个密文字节。密码系统的安全性取决于密钥流的性能。 流密码类似于一次一密，但是一次一密使用的是真正的随机数流。 一次一密密码：密钥流是完全随机序列，且密钥不重用。一次一密在唯密文攻击条件下是理论保密的，这是唯一一个能被证明是无条件安全的密码。 流密码可以分为：同步流密码和自同步流密码 同步流密码：密钥流生成器独立于明文字符。 对于明文而言，加密过程是无记忆的；解密过程要求密钥流和加密密钥流完全同步。 通信双方有相同的种子序列和初始状态，就可以产生相同的密钥。 自同步流密码：密钥流生成器与明文字符有关。 是有记忆的：时刻的密文与时刻的明文和时刻之前个明文符号有关。 有自同步能力。 明文每个字符扩散在密文多个字符中，强化了抗统计分析的能力。 8.5 线性反馈移位寄存器 LFSR 密钥发生器的组成：驱动部分（提供统计特性好的序列）和非线性组合部分（变换成密码学特性好的序列） 反馈移位寄存器是序列密码设计中常用乱源。目的是以种子密钥为序列的初态，按照确定的递推关系，产生一个周期长、线性复杂度高、统计特性好的初始乱源，然后利用密码变换，最终产生抗破译能力强的乱数序列。 一个反馈寄存器由两部分组成：移位寄存器和反馈函数。如果反馈函数、是n个变量的线性函数，则称为线性反馈移位寄存器(LFSR)。输出的序列称为线性反馈移位寄存器序列，记为LFSR序列。 把多项式f(x)称为LFSR的特征多项式 例题： 反馈移位寄存器的功能完全由其反馈逻辑函数决定。 移位寄存器的序列存在周期。能达到最长周期的序列称为m序列。 表示方法： 8.6 流密码RC4算法 RC4分为密钥调度算法（KSA）和伪随机数生成算法（PRGA） ​ KSA使用密钥生成原始S表。 ​ PRGA使用S表产生流密钥序列。 加密单位是字节。密钥长度1-256字节任意。 密钥调度算法： RC4使用了一个2^8字节大小的非线性数据表(简称S表)，对S表进行非线性变换，得到密钥流。 12345S = [i for i in range(256)]T = [k[i % len(k)] for i in range(256)]for i in range(256): j = j + S[i] + T[i] % 256 S[i], S[j] = S[j], S[i] 伪随机数生成算法： 1234567i, j = 0, 0while True: i = i + 1 % 256 j = j + S[i] % 256 S[i], S[j] = S[j], S[i] t = S[j] + S[i] % 256 k = S[t] 通过设计合适的伪随机数发生器，当密钥长度相当时，流密码可提供和分组密码一样的安全性。 对于流密码，如果用流密码对两个明文加密且使用相同密钥，则密码分析就会相当容易：如果对两个密文流进行异或，那么得出的结果就是两个原始明文的异或。 9. 公钥密码与 RSA 9.1 公钥密码原理 公钥，私钥 可提供的安全服务： 保密性：任何人可以使用公钥加密，只有私钥持有者可以用私钥解密。 不可否认性：只有私钥持有者可以使用私钥签名，任何人可以使用公钥认证。 公钥密码技术研究的基本工具不再像对称密码技术那样是代替和置换，而是数学函数。公钥密码体制的这种安全性理论基础只是基于复杂性理论的一种计算安全性。 公钥密码体制由6部分组成：明文密文、公钥私钥、加密解密算法。 公钥密码体制的主要特点是采用两个密钥将加密和解密能力分开。 使用公钥密码进行加密时，由于任何人都可以使用公钥进行加密，因此得到的密文不具有认证性，即无法确定是谁发的。因此要同时实现保密性和认证性，要采用双重加密：先用自己的私钥进行签名，再用对方公开的公钥加密后公开。 公钥密码应该满足的条件： 单向函数不能用于加密。丹恒单向陷门函数对于不知道陷门的人表现出单向函数的特性，可以用于加密。因此设计公钥密码体制变成了寻找单向陷门函数。公钥密码思想的首创者Diffie和Hellmen指出：计算复杂性中的NP完全问题可被用作设计公钥密码算法。 可提供单向函数的数学难题是： 大整数分解问题：RSA 有限域的离散对数问题：DH协议 椭圆曲线上的离散对数问题：SM2 9.2 RSA公钥算法 RSA是一种分组加密算法，明文和密文在0到n-1之间，n是一个正整数，公钥为(e,n)，私钥为(d,n) 算法的数学基础是初等数论中的Euler(欧拉)定理，并建立在大整数因子分解的困难性之上 其中包括三个算法：密钥生成算法、加密算法、解密算法 密钥生成算法： 两个不同但是大小相近的大素数p和q，n=pq，整数e满足 ，计算d满足 。则 为公钥， 为私钥。 加密算法： 将明文M分组，使得每组的内容十进制数小于n，即分组长度小于（小于比n小的2的最大次幂）（分组大小，满足），对每组明文做运算： 解密算法： 算法的正确性证明 RSA的安全性是基于加密函数是一个陷门单向函数，陷门是分解，进而用欧式法则求出私钥d。 优点：第一个能同时用于加密和数字签名的算法，也易于理解和操作；符合计算机网络的环境；对于大量用户，可以将加密密钥用电话簿的方式印出。 缺点：产生密钥很麻烦；分组长度太大，运算代价很高，尤其是速度较慢。 9.3 RSA中的计算问题 快速模幂算法 平方和乘法将计算的模乘法数目缩小到至多，为c的二进制表示的比特数 如n以二进制表示有k比特，即，则有 因此计算可以在时间内完成。 为了提高加密速度，e可以取特定的小整数，如，或者3。但是RSA也是无法达到对称密钥的运行速度。具体应用中将RSA算法更多地用于密钥的安全传输过程，而在针对具体传输信息 的加密与解密中依靠对称密钥算法，这样便能够增进密码系统的运行速度。 解密的快速实现 密钥生成 采用概率素数判定测试(如：Miller Rabin)找到可使用的p和q 9.4 RSA的安全性分析 p和q大约是100位的十进制数，n长度不少于512比特 要很大，且pq的长度相同 p和q最好位强素数： 强素数需满足：p-1也有大的素数因子r，p+1也有大的素数因子，r-1仍有大的素数因子 9.4.1 因式分解攻击 有三种途径：分解n；能计算出；能直接确定d 转移到2048位的RSA、Diffie-Hellman或DSA密钥 9.4.2 参数选取不当造成的攻击 要很大 如果小，则也小，此时稍大于n，即稍大于 顺序检查大于的每一个数x，找到某个x使得可以被开方为y，则 9.4.3 选择密文攻击 RSA算法有同态的特点： RSA最优非对称加密填充（RSA-OAEP）可抗击适应性选择密文攻击。 9.4.4 共模攻击 不同用户之间不要共享整数n 若一个用户有一个模数n，而拥有多组不同的e和d。若存在同一信息P分别用不同的公钥加密，若e1和e2恰好互质（存在），则可以得到P： 9.4.5 小指数攻击 9.4.6 解密密钥的安全 在私钥d被泄露的情况下，整数n也不再安全，重新选择e也无法保证安全性，必须重新选择n。 计算解密密钥d的难度并不小于对整数n进行素因子分解的难度。 如果获得一个 的非平凡平方根，则可以在多项式时间内完成对n的分解。 10. 其他密码体制 10.1 Rabin密码体制 Rabin密码体制已被证明对该体制的破译与分解大整数是等价的 不以一一对应的单向陷门函数为基础，对同一密文，可能有两个以上对应的明文 密钥生成算法： 选择两个大素数pq满足，计算 n为公钥，p,q为私钥 加密： 解密：求解 ，由CRT知该方程等价于解方程组： 由于 ，方程组的解容易得出，每个方程都由两个解。因此可以得到四个可能的解，即每一密文对应的明文不惟一。 为了有效确定明文，可在m中加入某些双方商定的信息，如日期、发送者的ID等。 例题： 10.2 Diffie-Hellman密钥交换 Diffie-Hellman算法可以用于密钥分配，但是不能用于加密或解密信息。 安全性依赖于有限域上计算离散对数非常困难。 算法流程： AB协商一个大素数p和本原根a，a和p公开 A产生随机数x，计算，X发给B B产生随机数y，计算，Y发给A A计算 B计算 Diffie-Hellman密钥交换容易受到中间人攻击，原因是Diffie-Hellman密钥交换不认证对方。 改进的Diffie-Hellman密钥交换算法： 非交互双方密钥协商协议 有一组用户，每个用户都产生一个长期密钥Xi，并计算公开的Yi 全局g和a 任何用户都可以访问该用户的公开值，计算密钥，用密钥对消息加密后发送给A 优点：若该中心目录是可信的，则这种形式的通信既可保证保密性（只有i和j可以确定密钥，所有其他用户均不能读取该消息），又可保证某种程度的真实性（接收方i知道只有用户j能用该密钥产生消息）。 多方的Diffie-Hellman： 10.3 ElGamal密码体制 双钥密码体制，用于加密和签名 安全性基于求解离散对数问题的困难性。 密钥生成算法： 选取一个足够大的素数q，在上选取一个本原元a 随机选取一个整数 ，并计算 公钥为 ，私钥为 加密： 消息 。以分组密码序列的方式来发送信息，每个分组的信息大小不超过q。 选择任意整数 一次性密钥 得到密文对： 解密： 推导过程： 例题： 密文由明文和所选随机数来确定，因而是非确定性加密，或称为随机化加密。 如果信息必须分组然后以加密的密钥序列发送，那么每一个分块要有唯一的k。如果k用于多个分块。利用信息的分块M1，攻击者会计算出其他块。 方法：两个C2和做比，K被约掉。 10.4 ECC 10.4.1 椭圆曲线密码简介 基于椭圆曲线数学的一种公钥密码的方法。 椭圆曲线上的公钥密码体制的优点：速度快、密钥短、存储空间和传输带宽占用较少，安全性高，灵活性好。 基于椭圆曲线离散对数问题的困难性。 国家标准与技术局和ANSI X9已经设定了最小密钥长度的要求，RSA和DSA是1024位，ECC是160位，相应的对称分组密码的密钥长度是80位。 10.4.2 实域R上的椭圆曲线 无穷远点：平行线交于无穷远点，则平面上所有直线都有唯一的交点 椭圆曲线为曲线 上的点，外加无穷远点 其中参数ab满足 ，则椭圆曲线构成一个群，并定义加法运算 如果椭圆曲线上的三个点位于同一直线上，那么它们的和为无穷远点（零点）。 其中O为加法的单位元。，则负元定义为： 点Q的倍点：做Q的切线，与椭圆曲线交于点S， 10.4.3 Zp上的椭圆曲线 定义： 曲线所有的解(x,y)，连同无穷远点定义为Zp上的一个椭圆曲线，记为 上的椭圆曲线点加公式： 其中： 10.4.4 GF(2^m)上的椭圆曲线 方程为： 使用生成元 10.4.5 椭圆曲线密码体制 椭圆曲线密码体制(ECC)，其依据是定义在椭圆曲线点群上的离散对数问题的难解性。 ，且P的阶很大（，t很大）。取，则的求解是难处理的。 一般数域上的离散对数问题（以及大数分解问题）存在亚指数级时间复杂度求解算法，而ECDLP只有纯指数算法。 用椭圆曲线实现Diffie-Hellman密钥交换 用椭圆曲线实现ElGamal密码体制 例题： ECC技术要求： p越大越安全，但是会变慢，200bit左右即可 G是基点，n是G的阶，n应该为质数 h是椭圆曲线上所有点的个数m与n相除的商的整数部分， 优点; 安全性高 密钥量小 灵活性好 速度快 适合嵌入式设备 11. 密码学Hash函数 11.1 密码学hash函数的应用 哈希函数用于将任意长的消息映射为较短的、固定长度的一个值。对于大的输入集合使用该函数，输出结果应该分布均匀且看起来随机。 Hash函数首要目标是保证数据的完整性，对于任何一位或几位的改变都将极大可能改变其hash码。 散列函数是一种单向密码体制，即它从明文到密文是不可逆映射，并且找到两个不同的数据块对应相同的Hash值在计算上不可行。 MD系列：1978年，Merkle和Damagad设计MD迭代结构。 SHA系列：SHA1、SHA2都是迭代结构。Keccak被选为SHA-3，采用了创新的“海绵引擎”散列消息文本。 国密：SM3，采用MD结构，输出值为256比特。 哈希函数在密码学中的应用：消息认证码、谁在前面、伪随机数发生器、一次性口令 在区块链中的应用：快速验证、防止篡改、POW工作量证明 消息认证： 是验证消息完整性的一种服务。确保受到的数据不变且发送方的身份有效。 方法1：AB共享一个密钥，消息与其杂凑码链接后用单钥加密算法加密 方法2：用单钥加密算法仅对杂凑码加密，这种方式用于不要求保密性的情况下，可减少处理负担 方法3：AB共享一个秘密值S，A计算消息和秘密值链接在一起的杂凑值，并将此杂凑值附加到消息后发往B 方法4：在上一种方式的基础上，在消息与杂凑值链接以后再增加单钥加密运算 方法5：用公钥加密算法，将消息和用发送方的密钥签名消息的杂凑码连接在一起 方法6：方法5之后再使用单钥加密算法加密。这种方式提供了保密性和数字签名 数字签名： 使用用户的私钥加密消息的Hash值，其它任何知道该用户公钥的人通过数字签名验证消息的完整性。 可以减少签名长度，提高签名速度；可以不泄露签名对应的信息。 11.2 安全性需求 Hash函数安全性条件：伪随机性:映射分布均匀性和差分分布均匀性 使输入中每一个比特的信息，尽量均匀地反映到输出的每一个比特上去 输出中的每一个比特，都是输入中尽可能多比特的信息一起作用的结果 01个数大致相等、雪崩效应、1个变化一半以上变化 杂凑函数的攻击：伪造消息，使其与原来消息的杂凑码相同 攻击方法：穷举攻击（原像攻击和第二原像攻击、碰撞攻击）、算法分析 评价hash算法抗密码分析能力的方法是：与穷举攻击所需的代价相比，理想的hash函数算法要求密码分析攻击所需代价大于或等于穷举攻击所需代价。 穷举攻击：不依赖于任何算法细节，仅与Hash值长度有关，包括 原像攻击和第二原像攻击：给定hash，找到这个杂凑值的消息。攻击规模是，平均尝试次 碰撞攻击：找到两个信息满足哈希值相等。两种常用的攻击方法：生日攻击法和中点交会攻击法。 第一类生日攻击： 问题：H有n个可能的输出， 是一个特定的输出，对H取k个输入，至少有一个输入y使得时，k有多大？ y取k个随机值得到函数的k个输出中至少有一个等于H(x)的概率为：。若概率等于0.5，则。当输出长为m比特时， 第二类生日攻击： 寻找函数H的具有相同输出的两个任意输入 设哈希函数输出长度为m比特，H的k个随机输入中至少有两个产生相同输出的概率大于0.5，则： 11.3 迭代型哈希函数 输入消息M分为L个长度为b位的分组（），若不能正好分组，需要填充到b的整数倍位。f为压缩函数。 Hash函数的一般结构为： 迭代技术（压缩函数f）： 由于函数的输入包含了长度，所以攻击者必须：找出具有相同的Hash值且长度相等的两条消息，或者长度不等但是加入消息长度后Hash相同的消息，增加了攻击的难度。 Merkle和Damgard已经证明：如果压缩函数是无碰撞的，则上述方法得到的Hash函数也是无碰撞的。因此Hash函数的核心是设计无碰撞的压缩函数f，要求找出f的碰撞在计算上是不可行的。 11.3.1 MD5 迭代型散列函数 输入：任意长度。分组：512比特。输出：128比特。 算法步骤： 填充，填充的第一位是1，其余为0。填充到比512的倍数少64位（），原始已经满足长度要求的数据也需要填充。 附加消息长度：将原始消息长度用64位表示，先填充低32位，后填充高32位。长度超过64位的取低64位。经过1、2步预处理后，消息长度为512的倍数，分组： 初始化缓冲区：中间结果和最终结果都保存在128位的缓冲区里。缓冲区用4个32位寄存器表示。对4个缓冲区附初始值，并以小端格式存储。 以512位的分组为单位处理消息：迭代执行压缩函数： 由四轮组成，每轮中对四个缓冲区进行16次迭代，每步迭代中使用当前512比特分组中的一个字（32比特）。 每轮中使用当前分组的16个字的顺序不一样。每轮中使用的逻辑函数g执行的位运算也不同。常数表的作用是“随机化”32位的输入数据，消除输入数据的规律性。循环左移的值与迭代的部步数和轮数都有关。加法是模相加。 输出：第L个分组处理后就是x的散列值。 安全性：MD5杂凑码中输出的每一比特是所有输入比特的函数，因此获得了很好的扩散效果。 从穷举搜索的角度，第二类生日攻击需要进行次运算，因此认为MD5容易受到第二类生日攻击。 11.3.2 SHA-1 迭代型哈希函数 输入：长度小于的消息。分组大小：512比特。输出：160比特。 算法步骤： 填充，与MD5相同 附加消息长度：用64位表示长度，并以大端存储的方式附加在后面 初始化缓冲区：中间结果和最终结果都保存在160位的缓冲区里。缓冲区用5个32位寄存器表示。对5个缓冲区附初始值，并以大端格式存储。 以512位分组为单位处理消息：压缩函数： 共四轮处理，每轮20次迭代。 分组中前16个字直接使用，后面使用计算，输入分组的16个字扩展成80个字以供压缩函数使用。基本逻辑函数执行位运算，每轮不同。加法是模相加。 输出 安全性：SHA1抗穷举攻击的能力比MD5强，并且抗密码分析的能力不弱。 11.3.3 SM3 迭代型哈希结构 分组长度：512位。输出长度：256位。 算法步骤： 填充：填充到512位的倍数，方法与MD5一样。 消息扩展：对每个分组产生132个消息字，每个消息字长32位。 迭代压缩：使用消息字进行迭代。 输出 11.4 海绵结构：SHA-3 SHA-3 第三代安全散列算法，之前名为Keccak算法。 海绵函数允许输入长度和输出长度可变。 海绵结构包括两个阶段：吸水阶段和挤压阶段。 算法流程： 填充：消息n位，被分为k个长r的分组 对长度b=r+c的状态变量s进行操作，初值设为0，在迭代中更新。默认下c=1024, r=576 吸水阶段：填充c个零，将输入从r位扩展到b位；扩展后与s进行运算，作为迭代函数f的输入，输入结果为s的新值 挤压阶段：每轮迭代中s的前r位保留作为输出分组Zi 输出：输出数据块的个数j由需要输出的位数l决定： 11.5 基于分组密码的Hash函数 CBC和CFB工作模式的特点：一个明文块的改变，在加密时会引起相应的密文块及其后的所有密文块改变。因此可利用分组密码的CBC和CFB工作模式构造Hash函数。 构造方式： 链接变量作为密钥：上一轮的输出作为下一轮的密钥 基于密码分组链接(CBC)工作模式：上一轮的输出与下一组消息异或，然后被加密 基于密码反馈(CFB)工作模式：上一轮的输出在下一轮中被加密，解密结果与这组消息进行异或 基于分组密码CBC和CFB工作模式的Hash函数中的密钥k： 若k保密，则是带密钥的Hash函数，常用于产生MAC，用于保证消息的完整性。 若k公开，则此类Hash函数是不安全的，甚至不是弱无碰撞。 11.6 基于离散对数的Hash函数 Chaum-Heijst-Pfitzmann Hash函数： 基于离散对数问题，可以证明是安全的 p是一个大素数，是一个素数，a和b是Zp的两个本原元。定义hash函数为： Chaum-Heijst-Pfitzmann Hash函数是强抗碰撞的。 证明：用反证法。若Hash函数h有一对碰撞，则可证明离散对数能被有效计算。 12. 消息认证码 12.1 对消息认证的要求 验证的内容包括： 所收到的消息确实来自真正的发送方 消息没有被修改 也可以验证消息的顺序和及时性 12.2 消息认证函数 认证符的产生有三类： 哈希函数：消息映射为定长的哈希值，以哈希值作为认证符 消息加密：对整个消息加密后的密文作为认证符 消息认证码：是消息和密钥的函数，产生定长的值 利用对称密码进行认证： 发送端：将明文消息M作为某个函数F的输入，产生帧校验序列（FCS），M和FCS连接到一起后进行加密 接收端：解密，重新利用F函数计算M的FCS，如果计算得到和收到的FCS相等，则认为消息是真实的 公钥加密：先签名再加密：提供保密性和认证性 消息认证码MAC：是指消息被一密钥控制的公开函数作用后产生的、用作认证符的、固定长度的数值。。 MAC是实现有效、安全可靠数字签字和认证的重要工具，是安全认证协议中的重要模块。 MAC算法不要求可逆性，想是带有密钥的Hash函数。但是也不是加密函数，因为MAC算法不要求可逆性，与加密函数相比，MAC函数更不容易被攻破。 12.3 MAC的安全性 攻击目的： 伪造攻击：攻击者在没有密钥的情况下，伪造一个未经认证的对 密钥恢复攻击：攻击者通过分析一系列消息、认证码对，找到控制密钥 伪造攻击 密钥恢复攻击：考虑敌手使用穷搜索攻击获取密钥 密钥有种，MAC值有种，，敌手知道多对信息和其认证码 第一轮：对于，穷举所有的密钥，由于密钥数多于MAC值的取值，因此有个密钥可能是正确的 第二轮：对于，在上述密钥中遍历，找到也满足这个式子的密钥值，得到个密钥可能是正确的 不断重复：，则平均需要a轮 因此消息认证码的穷攻击比对使用相同长度密钥的加密算法的穷搜索攻击代价更大。 穷举攻击中，攻击者有通过攻击密钥空间和攻击MAC值两种办法 攻击密钥空间： 密钥长k位，对所有可能的密钥进行计算，至少有一个密钥会产生正确的MAC，代价为 根据上述的密钥恢复攻击，可知存在一些不是正确密钥的密钥也会导致某个信息的认证码是相同的，因此需要不断重复，使用别的消息进行检查。可以证明，检查这些消息总的代价是： 攻击MAC值： 目的是对给定的消息产生其有效的MAC或者对给定的MAC产生其给定的消息 与攻击具有单向性或抗弱碰撞能力的Hash码所需的代价相同，代价为 这种攻击方式不能离线进行 MAC的构造： 用hash函数构造MAC 用分组密码构造MAC 用伪随机算法构造MAC 12.4 基础Hash函数的MAC：HMAC HMAC能提供： 消息完整性认证 信源身份认证 HMAC的设计目标： 可以不经修改直接使用现有的哈希函数 镶嵌的哈希函数可以方便的被替换 保持镶嵌的散列函数的最初性能，不因用于HMAC而使其性能降低 以简单的方式处理密钥 在对镶嵌的散列函数合理假设的基础上，易于分析HMAC用于认证时的密码强度 -&gt; 是HMAC优于其他基于散列函数的MAC的一个主要方面，HMAC在其镶嵌的散列函数具有合理密码强度的假设下，可证明是安全的。 算法描述： L：M消息分组数，b：一个分组中的比特长度，n：哈希函数的输出长度 K密钥长度左边填充0到b比特长，如果K的长度大于b，则先对K进行哈希后填充。得到K' K'与ipad异或，后面链接M的分组 哈希上面的所有分组 K'与opad异或，将上一步的哈希链接在异或值后 进行hash，输出值为HMAC HMAC的有效实现： 12345678910111213141516def sha1_hmac(key, message: bytes): # 将密钥和消息分别进行填充 if len(key) &gt; 64: key = sha1(key) key += b'\\x00' * (64 - len(key)) ipad = b'\\x36' * 64 opad = b'\\x5c' * 64 # 图中虚线的部分可以提前计算，用于作为散列函数的初值IV k_ipad = bytes([x ^ y for x, y in zip(key, ipad)]) k_opad = bytes([x ^ y for x, y in zip(key, opad)]) # 计算HMAC-SHA1值 inner_hash = sha1(k_ipad + message) outer_hash = sha1(k_opad + inner_hash) return outer_hash HMAC的安全性 HMAC的安全取决于镶嵌的哈希函数的安全性。 证明了对HMAC的攻击等价于对内嵌散列函数的下述两种攻击之一： 攻击者能够计算压缩函数的一个输出，即使IV是随机的和秘密的。 攻击者能够找出散列函数的碰撞，即使IV是随机的和秘密的。 13. 数字签名 13.1 数字签名的基本概念 数字签名主要用于对数字消息进行签名，以防消息的冒名伪造或篡改，也可用于通信双方的身份鉴别。 需要具有可验证性和不可伪造性。 数字签名的主要功能： 确认信息是由签名者发送的 确认消息自签名后到收到为止，未被修改过 签名者无法否认签名是由自己发送的 一个数字签名包含三部分：密钥生成、签名算法、验证算法 数字签名的安全性： 四类攻击目标从前至后难度依次递减： 四类攻击能力从前至后逐渐增强： 数字签名的解决方案： 数字签名方案的分类： 13.2 常见的数字签名方案 13.2.1 ElGamal签名 随机数k不能泄露且不能被重复使用，否则x有可能被算出 存在ElGamal数字签名的变形在某些假设下，能被证明在选择消息攻击下是安全的 13.2.2 Schnorr数字签名 Schnorr数字签名方案的安全性分析 ElGamal系统中是中的本原元，而Schnorr中不是。因此ElGamal的安全性更高，因为 的阶更高。 Schnorr系统的签名文较短，e的长度由函数h决定 Schnorr首先提出可以提前计算，因此实现过程更快 13.2.3 ECDSA 13.2.4 SM2 椭圆曲线： 验证算法的特点：加入了较多的检错功能，防止信道干扰和对手的篡改。 目前尚没有发现求解椭圆曲线离散对数问题的亚指数算法。 软硬件实现规模小，容易实现160位的椭圆曲线密码的安全性，相当于1024位的 RSA密码。目前最大的应用是二代身份证。 14. 密钥的管理和分发 14.1 密钥管理 密钥管理原则： 攻击者无法窃取 即使窃取到了也无法使用（超过使用时间和范围限制） 密钥的分配和更新对用户透明 密钥产生： 长度应该足够 密钥生成算法要足够安全：密钥生成算法的安全性不应低于密码算法的安全性 避免使用弱密钥，应使用长密钥 密钥生成算法： 非线性密钥空间：算法生成的密钥的强度不一致 线性密钥空间：密钥强度一致 防止我方黑盒密码设备被敌方利用： 密钥分为前后两部分，前一部分是密钥，后一部分是一个固定值用该密钥加密后得到的字符串 设备执行时，先解密后面的字符串，若匹配则正常。若不匹配，使用另外一个弱算法。 密钥128位，识别串64位，随机选取一个得到好密钥的概率是 密钥验证：确认来自正确的人；确认密钥没有传输错误（附带一个用该密钥加密的密文） 密钥更新：用旧密钥计算、用旧密钥协商，新密钥的安全性不会超过旧密钥。重新认证身份并分发密钥。旧密钥必须销毁。 14.2 基于对称加密的对称密钥分发 两个用户使用单钥密钥体制的时候，必须先共享一个密钥，还需要经常更新密钥。 密码系统的强度也依赖于密钥分配技术。 密钥分配的基本方法： 密钥由A选取并通过物理手段发送给B 密钥由第三方选取并通过物理手段发送给AB 如果AB事先已有一密钥，则其中一方选取新密钥后，用已有的密钥加密新密钥并发送给另一方。 缺点：攻击者一旦获得一个密钥就可获取以后所有的密钥，同时用这种方法对所有用户分配初始密钥时，代价仍然很大。 如果AB与第三方分别有一保密信道，则第三方选取密钥后，分别在两个保密信道上发送给AB 第四种方法比较常用，其中的第三方通常是一个负责为用户分配密钥的密钥分配中心(KDC)。这时每一用户必须和密钥分配中心有一个共享密钥，称为主密钥。通过主密钥分配给一对用户的密钥称为会话密钥，通信完成后，会话密钥即被销毁。主密钥可通过物理手段发送。 密钥分配的具体过程： A向KDC发送 Request 和 N1（这次业务的唯一标识符，是一个随机数，防止重放和篡改） KDA返回一个由（A保存的主密钥的）加密的信息，保证只有A能解密。解密信息包括：，Request，N1， A得到会话密钥。并向B转发最后一项的内容。由于最后一项是由B的主密钥加密的，因此只有B可以解密。并且可以获取会话密钥和对话的另一方的ID B用会话密钥加密一个随机数N2发给A A以f(N2)返回作为对B的应答，f函数可以是对N2加一等操作。 45两步可以让B相信第三步收到的消息不是一个重放。第三步已经完成了密钥分配，45两步还完成了认证的功能。 密钥的分层控制： 网络中如果用户数目非常多且分布的地域非常广，则需要使用多个KDC的分层结构 分层结构可减少主密钥的分布，还可将虚假KDC的危害限制到一个局部区域，但会降低信任度 分布式密钥控制： 在上述方法中需要所有用户都信任KDC，还需要对KDC加以保护。如果密钥分配是无中心的，则可以不需要KDC，但是主密钥多达个。 在整个网络的局部范围却非常有用 密钥的控制使用： 主密钥：密钥加密密钥。会话密钥：数据加密密钥。 如果主密钥泄露了，则相应的会话密钥也将泄露，因此主密钥的安全性应高于会话密钥的安全性。 会话密钥的有效期： 会话密钥更换得越频繁，系统的安全性就越高。 会话密钥更换得太频繁，又将延迟用户之间的交换。 14.3 基于非对称加密的对称密钥分发 公钥用于分配单钥密码体制的密钥非常合适。 简单分配流程： 公钥缺少证书管理机构认证且非物理传输中容易受到中间人攻击。 具有保密性和认证性的密钥分配： 假定AB双方已完成公钥交换，则可按以下步骤建立共享会话密钥： 14.4 公钥分发 公开发布 公用目录表 公钥授权 优点：每次密钥的获得由公钥管理机构查询并认证发送，用户不需要查表，提高了安全性 缺点：公钥管理机构必须一直在线，由于每一用户要想和他人联系都需求助于管理机构，所以管理机构有可能成为系统的瓶颈。由管理机构维护的公钥目录表也易被敌手通过一定方式窜扰。 公钥证书 用户通过公钥证书来互相交换自己的公钥而无须与公钥管理机构联系 公钥证书由证书管理机构CA(certificate authority)为用户建立 A 将自己的公钥发给CA，CA返回A的公钥证书 X.509认证服务 证书机构Y颁发给用户A的证书表示为：。 V是版本号，SN是证书序号，AI是证书算法标识，CA是发行者，TA是有效期，A是用户信息，AP是A的公钥 任何可以访问CA的用户都可以得到一个证书，只有CA可以修改证书。由于证书用CA的私钥签名，不能伪造，因此可以放在一个公共目录中。 不共享同一CA的用户获得证书： 两个CA之间已经交换了公开密钥，含有对方的证书。则A可以先读取，获取X2的公钥后，在读取，读取B的公钥。 这个证书链可以表示为： 证书的撤销：每一个证书都具有一个有效期，有效期结束时证书将自动撤销。也可以在有效期结束前撤销。为了有效的管理证书的撤销，CA会维护一个证书撤销列表CRL。当用户获取一个证书时，应检查CA的CRL，判断该证书是否已被撤销。 14.5 公钥基础设施（PKI） 为管理公钥（生成、认证、存储、安装），须建立一套公钥基础设施（PKI，Public Key Infrastructure），PKI的基本组成元素是证书颁发机构（CA，Certificate Authority）。 PKI主要完成的工作为： 为用户生成一对密钥（公开密钥，私有密钥），并通过一定的途径分发给用户。 CA为用户签发数字证书，形成用户的公开密钥信息，并通过一定的途径分发给用户。 对用户证书的有效性进行验证。 对用户的数字证书进行管理。这些管理包括有效证书的公布、撤销证书的公布、证书归档等。 PKI包含五个关键元素： 端实体：一个在公钥数字证书作用范围中被认证的实体。 签证机构CA：证书和证书撤销列表的发行人。 注册机构RA：可选元素，承担一些签证机构（CA）的管理任务。 证书撤销列表发布点：可选元素，CA可通过它来发布证书撤销列表（CRL）。 证书存取库：必备元素，提供存取数字证书和证书撤销列表的方法。","link":"/2023/06/04/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"秘密共享","text":"1. 基本概念 1.1 介绍 参考资料：《密码协议基础》第8章 1.2 符号介绍 ：全部参与的人数 ：门限值，即任意t个参与者可以恢复出秘密，但少于t个参与者无法计算出关于原秘密的任何信息 是q阶有限域，其中 为素数 ：要分享的秘密 ：秘密碎片 ：秘密分发者 ：参与者 2. Shamir 秘密分享体制 2.1 前置知识：Lagrange插值多项式 已知n+1个点x1，x2，…，xn的函数值，可以使用lagrange插值求出一个n次多项式插值函数f(x),f(x)是接近未知原函数p(x)的函数，根据插值函数f(x)求出p(x)的未知点. 拉格朗日插值基函数： 拉格朗日插值多项式公式： 2.2 秘密分发 D随机选择一个t阶多项式 ，并且 D将 发送给 2.3 秘密重构 利用Lagrange插值多项式可以计算出： 其中， 由于秘密是，则令，得到： 共t个参与者，参与者每个人计算： 恢复得到秘密： 3. 可验证秘密共享VSS 3.1 介绍 为解决不诚实分发中心的问题，秘密分发者不仅分发秘密的碎片，而且广播对秘密碎片的承诺，各成员收到碎片时，验证碎片是否正确，重构阶段也验证其他成员的秘密碎片的正确性。 因此相对于Shamir只能抵抗被动攻击，VSS可以抵抗分发者分发错误碎片和参与者提交错误碎片的主动攻击。 3.2 Feldman的VSS方案 为一个 大素数， 为 阶循环群， 为生成元 3.2.1 秘密分发 D选择一个随机多项式：，其中 ，各项系数均属于 。 D将 发送给 D广播承诺 参与者 收到自己的碎片 后，计算下式是否成立： 如果成立，表明该碎片有效；若不成立，则请求D重发正确的碎片 3.2.2 秘密重构 重构方法同Shamir 秘密分享体制，任意t个参与者向参与重构的其他合作者秘密广播自己的碎片，这样每个参与重构的成员都可以通过上述的方法验证所收到的碎片的有效性，并利用拉格朗日插值定理重构出秘密s。 3.3 Pedersen的VSS方案 Feldman的方案中将 也作为一个承诺发出，只是计算安全的。Petersen方案中进行了进一步的扩展，不会直接泄露秘密s，是无条件安全的。 为一个 大素数， 为 阶循环群， 为生成元， 是一个随机元素 3.3.1 秘密分发 D选取两个随机多项式$a(x) = {j = 0}{t-1}a_txt ,b(x) = {j = 0}{t-1}b_txt ，其中a_0 =s $ D将碎片 发给参与者Pi D广播承诺值 参与者 收到自己的碎片 后，计算下式是否成立： 如果成立，表明该碎片有效；若不成立，则请求D重发正确的碎片 3.3.2 秘密重构 重构方法同Feldman的方案。 4. 等长多项式承诺（Kate） 《Constant-Size Commitments to Polynomials and Their Applications》文献阅读笔记 4.1 介绍 对多项式承诺的两种方式： 对整个多项式进行承诺 即将这个多项式的系数通过某种方式链接在一起后进行承诺 但在揭示多项式中的某个点的值时会同时揭示整个多项式 对多项式的系数进行承诺 即对多项式的每个系数分别进行承诺 可以在不揭示整个多项式的情况下验证多项式在某个点的值是否与承诺一致，缺点是承诺的大小变大了。 4.2 定义 4.2.1 参数介绍 $$：安全参数 ：双线性配对群，其素数阶 4.2.2 多项式承诺 Setup()：生成公钥PK用于承诺，其中包含合适的代数结构e Commit()：使用PK对多项式进行承诺，输出承诺C和额外的信息d Open() VerifyPoly() CreateWitness()：是在i出的证据，输出 VerifyEval()：验证证据 4.3 PolyCommit_DL 计算安全 前提：在 上， 总能被 整除。 Setup() 和$_T 都是阶群，选择 的一个生成元g$ 为私钥，公钥为： Commit() 给定t次或小于t次的多项式，承诺。 由于，则承诺 Open() VerifyPoly()：验证 CreateWitness()：令，，输出 VerifyEval()：：验证 是C所承诺的多项式在下标i处的值。 4.4 PolyCommit_Ped 无条件安全 PolyCommit_DL是同态的，有多项式和，及其各自对应的承诺和。若，则，witness是 Setup() 和$_T 都是阶群，选择 的两个生成元g,h$ 为私钥，公钥为： Commit() 给定t次或小于t次的多项式，选择任意t次的随机多项式，承诺。 由于，则承诺 Open() VerifyPoly()：验证 CreateWitness()：令，，输出 VerifyEval()：：验证 是C所承诺的多项式在下标i处的值。 4.5 eVSS 在eVSS方案的Sh和Rec阶段，VSS方法与Feldman VSS方法完全相同，只是Feldman的t + 1个形如承诺被单个多项式承诺取代。 此外，除了共享si外，秘密发放者现在还向节点Pi发送一个见证wi。 总的来说，eVSS协议需要O(1)广播，而Feldman VSS需要O(n)广播。在多次指控的情况下，秘密发放者秘密发放者可以使用§3.4中描述的批量开启功能，为整个批次提供一个证人。此外，由于PolyCommit的同态性，eVSS方案可以很容易地转换为分布式密钥生成协议。 4.5.1 秘密分发 D选择一个次数为t的多项式，令，并广播承诺C=Commit() 对于，D计算秘密碎片 ，并CreateWitness()，输出通过安全可靠信道发送给Pi。 参与者Pi收到后，运行VerifyEval()。如果验证失败则向D发送验证失败的消息。 D如果收到收到大于t个VerifyEval验证失败的消息，则表明这个参与者中有过多的不诚实用户，是不合格的，无法继续进行。如果少于t个，则向报告失败的用户重发==（？）== 如果==revealed shares（？）== 在VerifyEval验证中失败，表明分发者D是不合格的。如果没有，表明各个参与者都接受了。 4.5.2 秘密重构 任何t + 1或更多的节点Pi发布他们接受的秘密碎片和见证。 所有t + 1(或更多)节点使用VerifyEval验证每个广播共享，然后插值对，确定秘密。 5. 高阈值异步可验证秘密共享（HAVSS） 《High-Threshold AVSS with Optimal Communication Complexity》文献阅读笔记 5.1 介绍 5.2 定义 5.2.1 算法定义 Setup Com：对要求次数，并输出一个承诺字符串 Eval：它输出一个包含i、计算值φ(i)和见证字符串wi的3元组。 Verify：输入y是Eval输出的一个三元组，进行验证 Hom：由于承诺的同态性质，输出的是 5.3 Haven的HAVSS协议，对一致采样的短秘密s 5.3.1 sharing phase 1）对秘密分发者D，收到 (ID.d, in, share, s) 随机生成多项式和承诺： 生成恢复多项式 R，次数为p，满足。 生成n个不同的随机的共享多项式S1, S2, ..., Sn，每个参与方都会收到其中要给，次数为t，满足。 计算R和Si多项式承诺： 。这些承诺用于检验多项式的一致性。 令。 构建验证所需数据：分发者生成检验需要的数据： 向量 ，其中包含第n个共享多项式 Si 在某个点的评估。这个向量中的值以转置的顺序排列，即第一个值是 S1(i)，第二个值是 S2(i)，以此类推。 n 个测试多项式 Ti，每个测试多项式是 R - Si，以证明份额多项式和恢复多项式之间的一致性，并计算 构建根承诺： 分发者构建了一个根承诺 ，这是一个向量承诺，包含了所有多项式承诺的信息。在后续的可靠广播协议中，服务器只会相信与根承诺 C 相关联的多项式承诺。并讲每个多项式的见证witness加入C中。 发送消息给参与方： 分发者向每个参与者发送：根承诺、恢复多项式的承诺、每个共享多项式的承诺$ ，每个人共享多项式见证_iS，以及所有测试多项式的评估T$。发送格式为：(ID.d, send, set_i) 2) 对参与者Pi，第一次从D收到消息 (ID.d, send, set_i) 时，进行回应 检验： 和 检验：恢复多项式的承诺和每个共享多项式的承诺都在跟承诺C中正确的位置上 检验： 向 发送：(ID.d, echo, info_ij) ，其中info中包含 重复上述操作， 3) 对参与者Pj从Pi第一次收到消息 (ID.d, echo, info_ij) 时 检验： 在C中的i位上，并且检验 如果自己还没有发送ready信息，并且已经收到了 2t+1 个有效的echo信息时：向所有人发送一个ready信息 (ID.d, ready, C) 4) 对参与者Pm第一次收到消息 (ID.d, ready, C) 如果自己还没有发送ready信息，等到收到 t+1 个他人发送来的ready信息后发送ready信息 如果已经收到了 2t+1 个ready信息了，则等到收到 t+1 个echo 信息时： 从 t+1 个有效的echo信息中对插值获得 计算 输出反馈信息：(ID.d, out, shared) 5.3.2 Reconstruction phase 1）receive (ID.d, in reconstruct) 向每个参与者Pj发送：(ID.d, reconstruct-share, , ) 2) receive (ID.d, reconstruct-share, , ) 如果 在C中并且验证： 如果接收到 p+1个有效的reconstruct-share 信息 则 利用 重构出R不等式，并输入 为秘密 6. 打包异步可验证秘密共享(PAVSS) 《Bingo: Adaptively Secure Packed Asynchronous Verifiable Secret Sharing and Asynchronous Distributed Key Generation》文献阅读 6.1 Introduction Bingo结合了所有这些增强功能：具体来说，它是一种自适应安全的打包异步可验证秘密共享(PAVSS)协议，该协议允许秘密发放者以个字的总通信复杂度共享f+1个秘密，其中n为各方的总数，f为恶意方的总数。此外，Bingo在假设n = 3f + 1时具有最佳弹性。","link":"/2023/08/24/%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/"},{"title":"Bingo：VABA Leader Election","text":"Bingo: VABA Leader Election() 注：当前操作用户始终是用户 零、开始阶段： 用户 初始化各集合为空集 用户 为每个其他参与方随机抽样一个秘密 作为 dealer 分三次调用 BingoShare 分享上述n个秘密 ==（为什么是3次，不懂？）== 对于其他参与者 发来的三次 BingoShare 请求都进行参与 一、如果完成了其他某个参与者 三次的BingoShare 请求，则： 将参与者 加入 集合中 如果 集合中有f+1个参与方，则 向所有人发送attach消息： 二、如果从其他某个参与者 收到attach消息，则： 如果收到的 集合是自己的 集合的子集，则 向参与者 发送signature消息： 三、如果从其他某个参与者 收到signature消息，则： 如果自己的 attached 集合不为空 并且使用参与者 验证这条sig 消息正确，则： 将参与者 和他的签名信息添加到自己收集的签名集合 中 如果收集到了其他 f+1 个人的签名，则： 调用 ， 并且调用 checkValidity 校验有效性 四、当Gather协议输出集合 时： 中每一项的下标，即 广播indices消息： 五、当第一次从其他某个参与者 收到indices消息 时： 调用 并得到结果 ，并且等待自己的 调用输出结果时， 对于 中的每个 ： ​ 对于 中的每个 ，以作为秘密发放者终止的所有BingoShare调用时：==（23行，这句话没看懂）== ​ 调用 六、如果BingoReconstructSum输出结果，则： 将 添加到集合 中 七、如果 不为空集，且 中每个参与方的评估结果都存在在 中时： 检查哪些参与方具有最大的关联值，并选择它作为领导者。==（30行没看懂，那个 集合是哪里来的）==","link":"/2023/09/04/Bingo_VABA_Leader_Election/"}],"tags":[{"name":"python","slug":"python","link":"/tags/python/"},{"name":"大二上","slug":"大二上","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8A/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"大二下","slug":"大二下","link":"/tags/%E5%A4%A7%E4%BA%8C%E4%B8%8B/"},{"name":"秘密共享","slug":"秘密共享","link":"/tags/%E7%A7%98%E5%AF%86%E5%85%B1%E4%BA%AB/"},{"name":"竞赛","slug":"竞赛","link":"/tags/%E7%AB%9E%E8%B5%9B/"}],"categories":[]}